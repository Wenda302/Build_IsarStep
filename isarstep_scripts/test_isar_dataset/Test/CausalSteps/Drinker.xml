<?xml version="1.0" ?>
<theory full_name="Test/Drinker.thy" processed_id="2022103162956">
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[1]" location_in_theorem_consequence="None" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_x_sq0">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ ( CONST Groups.plus_class.plus $ FREE &lt;X0&gt; $ CONST Groups.one_class.one ) ) $ ( CONST Groups.plus_class.plus $ ( CONST Groups.plus_class.plus $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ FREE &lt;X0&gt; ) ) $ CONST Groups.one_class.one ) )</target_fact>
      <target_fact_ascii>(&lt;X0&gt; + 1)\&lt;^sup&gt;2 = &lt;X0&gt;\&lt;^sup&gt;2 + 2 * &lt;X0&gt; + 1</target_fact_ascii>
      <target_fact_ascii_original>(x + 1)\&lt;^sup&gt;2 = x\&lt;^sup&gt;2 + 2 * x + 1</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isacharparenleft}x\ {\isacharplus}\ {\isadigit{1}}{\isacharparenright}\isactrlsup {\isadigit{2}}\ {\isacharequal}\ x\isactrlsup {\isadigit{2}}\ {\isacharplus}\ {\isadigit{2}}\ {\isacharasterisk}\ x\ {\isacharplus}\ {\isadigit{1}}\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ BOUND 0 ) $ ( CONST Groups.times_class.times $ BOUND 0 $ BOUND 0 ) ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;a. a\&lt;^sup&gt;2 = a * a</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ a\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\ {\isacharasterisk}\ a\&lt;close&gt;</used_global_facts_latex>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="0" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST Set.member $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ CONST Rat.field_char_0_class.Rats )</target_fact>
      <target_fact_ascii>sqrt 2 \&lt;in&gt; \&lt;rat&gt;</target_fact_ascii>
      <target_fact_ascii_original>sqrt 2 \&lt;in&gt; \&lt;rat&gt;</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isasymin}\ {\isasymrat}\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST Set.member $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ CONST Rat.field_char_0_class.Rats )</consequences>
      <consequences_ascii>sqrt 2 \&lt;in&gt; \&lt;rat&gt;</consequences_ascii>
      <consequences_ascii_original>sqrt 2 \&lt;in&gt; \&lt;rat&gt;</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isasymin}\ {\isasymrat}\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="0" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST Set.member $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ CONST Rat.field_char_0_class.Rats )</target_fact>
      <target_fact_ascii>sqrt 2 \&lt;in&gt; \&lt;rat&gt;</target_fact_ascii>
      <target_fact_ascii_original>sqrt 2 \&lt;in&gt; \&lt;rat&gt;</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isasymin}\ {\isasymrat}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Set.member $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ CONST Rat.field_char_0_class.Rats )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; sqrt 2 \&lt;in&gt; \&lt;rat&gt;</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isasymin}\ {\isasymrat}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Real.real_of_int $ FREE &lt;X0&gt; ) $ ( CONST Real.real_of_int $ FREE &lt;X1&gt; ) ) )</consequences>
      <consequences_ascii>sqrt 2 = real_of_int &lt;X0&gt; / real_of_int &lt;X1&gt;</consequences_ascii>
      <consequences_ascii_original>sqrt 2 = real_of_int a / real_of_int b</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ a\ {\isacharslash}\ real{\isacharunderscore}of{\isacharunderscore}int\ b\&lt;close&gt;</consequences_latex>
      <consequences_others>  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Set.member $ BOUND 3 $ ( CONST Set.image $ ( ABS BOUND 3 $ BOUND 0 ) $ BOUND 1 ) ) ) $ ( CONST Pure.imp $ ( CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 4 $ ( BOUND 3 $ BOUND 0 ) ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Set.member $ BOUND 0 $ BOUND 2 ) ) $ ( CONST HOL.Trueprop $ BOUND 1 ) ) ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 3 $ ( CONST Rat.Fract $ BOUND 1 $ BOUND 0 ) ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less $ CONST Groups.zero_class.zero $ BOUND 0 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 2 ) ) ) ) ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less $ CONST Groups.zero_class.zero $ BOUND 1 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ BOUND 0 $ BOUND 1 ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.normalize $ ( CONST Product_Type.Pair $ BOUND 0 $ BOUND 1 ) ) $ ( CONST Product_Type.Pair $ BOUND 0 $ BOUND 1 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.quotient_of $ BOUND 2 ) $ ( CONST Product_Type.Pair $ BOUND 1 $ BOUND 0 ) ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 2 $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Rat.rat_of_int $ BOUND 1 ) $ ( CONST Rat.rat_of_int $ BOUND 0 ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.field_char_0_class.of_rat $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Rat.field_char_0_class.of_rat $ BOUND 1 ) $ ( CONST Rat.field_char_0_class.of_rat $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.quotient_of $ ( CONST Rat.Fract $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Rat.normalize $ ( CONST Product_Type.Pair $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.field_char_0_class.of_rat $ ( CONST Rat.rat_of_int $ BOUND 0 ) ) $ ( CONST Int.ring_1_class.of_int $ BOUND 0 ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ CONST Rat.field_char_0_class.Rats $ ( CONST Set.range $ CONST Rat.field_char_0_class.of_rat ) )</consequences_others>
      <consequences_others_ascii_original>  &lt;SEP&gt; \&lt;And&gt;b f A thesis.
   \&lt;lbrakk&gt;b \&lt;in&gt; f ` A;
    \&lt;And&gt;x.
       \&lt;lbrakk&gt;b = f x; x \&lt;in&gt; A\&lt;rbrakk&gt;
       \&lt;Longrightarrow&gt; thesis\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; thesis &lt;SEP&gt; \&lt;And&gt;q C.
   (\&lt;And&gt;a b.
       \&lt;lbrakk&gt;q = Fract a b; 0 &lt; b; coprime a b\&lt;rbrakk&gt;
       \&lt;Longrightarrow&gt; C) \&lt;Longrightarrow&gt;
   C &lt;SEP&gt; \&lt;And&gt;q p.
   \&lt;lbrakk&gt;0 &lt; q; coprime p q\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; Rat.normalize (p, q) = (p, q) &lt;SEP&gt; \&lt;And&gt;r n d.
   quotient_of r = (n, d) \&lt;Longrightarrow&gt; r = rat_of_int n / rat_of_int d &lt;SEP&gt; \&lt;And&gt;a b. quotient_of (Fract a b) = Rat.normalize (a, b) &lt;SEP&gt; \&lt;And&gt;a b. of_rat (a / b) = of_rat a / of_rat b &lt;SEP&gt; \&lt;And&gt;z. of_rat (rat_of_int z) = of_int z &lt;SEP&gt; \&lt;rat&gt; = range of_rat</consequences_others_ascii_original>
      <consequences_others_latex>  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}b\ f\ A\ thesis{\isachardot}\ {\isasymlbrakk}b\ {\isasymin}\ f\ {\isacharbackquote}\ A{\isacharsemicolon}\ {\isasymAnd}x{\isachardot}\ {\isasymlbrakk}b\ {\isacharequal}\ f\ x{\isacharsemicolon}\ x\ {\isasymin}\ A{\isasymrbrakk}\ {\isasymLongrightarrow}\ thesis{\isasymrbrakk}\ {\isasymLongrightarrow}\ thesis\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}q\ p{\isachardot}\ {\isasymlbrakk}{\isadigit{0}}\ {\isacharless}\ q{\isacharsemicolon}\ coprime\ p\ q{\isasymrbrakk}\ {\isasymLongrightarrow}\ Rat{\isachardot}normalize\ {\isacharparenleft}p{\isacharcomma}\ q{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}p{\isacharcomma}\ q{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}r\ n\ d{\isachardot}\ quotient{\isacharunderscore}of\ r\ {\isacharequal}\ {\isacharparenleft}n{\isacharcomma}\ d{\isacharparenright}\ {\isasymLongrightarrow}\ r\ {\isacharequal}\ rat{\isacharunderscore}of{\isacharunderscore}int\ n\ {\isacharslash}\ rat{\isacharunderscore}of{\isacharunderscore}int\ d\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}q\ C{\isachardot}\ {\isacharparenleft}{\isasymAnd}a\ b{\isachardot}\ {\isasymlbrakk}q\ {\isacharequal}\ Fract\ a\ b{\isacharsemicolon}\ {\isadigit{0}}\ {\isacharless}\ b{\isacharsemicolon}\ coprime\ a\ b{\isasymrbrakk}\ {\isasymLongrightarrow}\ C{\isacharparenright}\ {\isasymLongrightarrow}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ quotient{\isacharunderscore}of\ {\isacharparenleft}Fract\ a\ b{\isacharparenright}\ {\isacharequal}\ Rat{\isachardot}normalize\ {\isacharparenleft}a{\isacharcomma}\ b{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ of{\isacharunderscore}rat\ {\isacharparenleft}a\ {\isacharslash}\ b{\isacharparenright}\ {\isacharequal}\ of{\isacharunderscore}rat\ a\ {\isacharslash}\ of{\isacharunderscore}rat\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}z{\isachardot}\ of{\isacharunderscore}rat\ {\isacharparenleft}rat{\isacharunderscore}of{\isacharunderscore}int\ z{\isacharparenright}\ {\isacharequal}\ of{\isacharunderscore}int\ z\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymrat}\ {\isacharequal}\ range\ of{\isacharunderscore}rat\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="0" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST Set.member $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ CONST Rat.field_char_0_class.Rats )</target_fact>
      <target_fact_ascii>sqrt 2 \&lt;in&gt; \&lt;rat&gt;</target_fact_ascii>
      <target_fact_ascii_original>sqrt 2 \&lt;in&gt; \&lt;rat&gt;</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isasymin}\ {\isasymrat}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Set.member $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ CONST Rat.field_char_0_class.Rats )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; sqrt 2 \&lt;in&gt; \&lt;rat&gt;</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isasymin}\ {\isasymrat}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</consequences>
      <consequences_ascii>coprime &lt;X0&gt; &lt;X1&gt;</consequences_ascii>
      <consequences_ascii_original>coprime a b</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt;</consequences_latex>
      <consequences_others>  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Set.member $ BOUND 3 $ ( CONST Set.image $ ( ABS BOUND 3 $ BOUND 0 ) $ BOUND 1 ) ) ) $ ( CONST Pure.imp $ ( CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 4 $ ( BOUND 3 $ BOUND 0 ) ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Set.member $ BOUND 0 $ BOUND 2 ) ) $ ( CONST HOL.Trueprop $ BOUND 1 ) ) ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 3 $ ( CONST Rat.Fract $ BOUND 1 $ BOUND 0 ) ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less $ CONST Groups.zero_class.zero $ BOUND 0 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 2 ) ) ) ) ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less $ CONST Groups.zero_class.zero $ BOUND 1 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ BOUND 0 $ BOUND 1 ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.normalize $ ( CONST Product_Type.Pair $ BOUND 0 $ BOUND 1 ) ) $ ( CONST Product_Type.Pair $ BOUND 0 $ BOUND 1 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.quotient_of $ BOUND 2 ) $ ( CONST Product_Type.Pair $ BOUND 1 $ BOUND 0 ) ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 2 $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Rat.rat_of_int $ BOUND 1 ) $ ( CONST Rat.rat_of_int $ BOUND 0 ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.field_char_0_class.of_rat $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Rat.field_char_0_class.of_rat $ BOUND 1 ) $ ( CONST Rat.field_char_0_class.of_rat $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.quotient_of $ ( CONST Rat.Fract $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Rat.normalize $ ( CONST Product_Type.Pair $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.field_char_0_class.of_rat $ ( CONST Rat.rat_of_int $ BOUND 0 ) ) $ ( CONST Int.ring_1_class.of_int $ BOUND 0 ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ CONST Rat.field_char_0_class.Rats $ ( CONST Set.range $ CONST Rat.field_char_0_class.of_rat ) )</consequences_others>
      <consequences_others_ascii_original>  &lt;SEP&gt; \&lt;And&gt;b f A thesis.
   \&lt;lbrakk&gt;b \&lt;in&gt; f ` A;
    \&lt;And&gt;x.
       \&lt;lbrakk&gt;b = f x; x \&lt;in&gt; A\&lt;rbrakk&gt;
       \&lt;Longrightarrow&gt; thesis\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; thesis &lt;SEP&gt; \&lt;And&gt;q C.
   (\&lt;And&gt;a b.
       \&lt;lbrakk&gt;q = Fract a b; 0 &lt; b; coprime a b\&lt;rbrakk&gt;
       \&lt;Longrightarrow&gt; C) \&lt;Longrightarrow&gt;
   C &lt;SEP&gt; \&lt;And&gt;q p.
   \&lt;lbrakk&gt;0 &lt; q; coprime p q\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; Rat.normalize (p, q) = (p, q) &lt;SEP&gt; \&lt;And&gt;r n d.
   quotient_of r = (n, d) \&lt;Longrightarrow&gt; r = rat_of_int n / rat_of_int d &lt;SEP&gt; \&lt;And&gt;a b. quotient_of (Fract a b) = Rat.normalize (a, b) &lt;SEP&gt; \&lt;And&gt;a b. of_rat (a / b) = of_rat a / of_rat b &lt;SEP&gt; \&lt;And&gt;z. of_rat (rat_of_int z) = of_int z &lt;SEP&gt; \&lt;rat&gt; = range of_rat</consequences_others_ascii_original>
      <consequences_others_latex>  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}b\ f\ A\ thesis{\isachardot}\ {\isasymlbrakk}b\ {\isasymin}\ f\ {\isacharbackquote}\ A{\isacharsemicolon}\ {\isasymAnd}x{\isachardot}\ {\isasymlbrakk}b\ {\isacharequal}\ f\ x{\isacharsemicolon}\ x\ {\isasymin}\ A{\isasymrbrakk}\ {\isasymLongrightarrow}\ thesis{\isasymrbrakk}\ {\isasymLongrightarrow}\ thesis\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}q\ p{\isachardot}\ {\isasymlbrakk}{\isadigit{0}}\ {\isacharless}\ q{\isacharsemicolon}\ coprime\ p\ q{\isasymrbrakk}\ {\isasymLongrightarrow}\ Rat{\isachardot}normalize\ {\isacharparenleft}p{\isacharcomma}\ q{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}p{\isacharcomma}\ q{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}r\ n\ d{\isachardot}\ quotient{\isacharunderscore}of\ r\ {\isacharequal}\ {\isacharparenleft}n{\isacharcomma}\ d{\isacharparenright}\ {\isasymLongrightarrow}\ r\ {\isacharequal}\ rat{\isacharunderscore}of{\isacharunderscore}int\ n\ {\isacharslash}\ rat{\isacharunderscore}of{\isacharunderscore}int\ d\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}q\ C{\isachardot}\ {\isacharparenleft}{\isasymAnd}a\ b{\isachardot}\ {\isasymlbrakk}q\ {\isacharequal}\ Fract\ a\ b{\isacharsemicolon}\ {\isadigit{0}}\ {\isacharless}\ b{\isacharsemicolon}\ coprime\ a\ b{\isasymrbrakk}\ {\isasymLongrightarrow}\ C{\isacharparenright}\ {\isasymLongrightarrow}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ quotient{\isacharunderscore}of\ {\isacharparenleft}Fract\ a\ b{\isacharparenright}\ {\isacharequal}\ Rat{\isachardot}normalize\ {\isacharparenleft}a{\isacharcomma}\ b{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ of{\isacharunderscore}rat\ {\isacharparenleft}a\ {\isacharslash}\ b{\isacharparenright}\ {\isacharequal}\ of{\isacharunderscore}rat\ a\ {\isacharslash}\ of{\isacharunderscore}rat\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}z{\isachardot}\ of{\isacharunderscore}rat\ {\isacharparenleft}rat{\isacharunderscore}of{\isacharunderscore}int\ z{\isacharparenright}\ {\isacharequal}\ of{\isacharunderscore}int\ z\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymrat}\ {\isacharequal}\ range\ of{\isacharunderscore}rat\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Real.real_of_int $ FREE &lt;X0&gt; ) $ ( CONST Real.real_of_int $ FREE &lt;X1&gt; ) ) )</target_fact>
      <target_fact_ascii>sqrt 2 = real_of_int &lt;X0&gt; / real_of_int &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>sqrt 2 = real_of_int a / real_of_int b</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ a\ {\isacharslash}\ real{\isacharunderscore}of{\isacharunderscore}int\ b\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Set.member $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ CONST Rat.field_char_0_class.Rats )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; sqrt 2 \&lt;in&gt; \&lt;rat&gt;</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isasymin}\ {\isasymrat}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Set.member $ BOUND 3 $ ( CONST Set.image $ ( ABS BOUND 3 $ BOUND 0 ) $ BOUND 1 ) ) ) $ ( CONST Pure.imp $ ( CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 4 $ ( BOUND 3 $ BOUND 0 ) ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Set.member $ BOUND 0 $ BOUND 2 ) ) $ ( CONST HOL.Trueprop $ BOUND 1 ) ) ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 3 $ ( CONST Rat.Fract $ BOUND 1 $ BOUND 0 ) ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less $ CONST Groups.zero_class.zero $ BOUND 0 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 2 ) ) ) ) ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less $ CONST Groups.zero_class.zero $ BOUND 1 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ BOUND 0 $ BOUND 1 ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.normalize $ ( CONST Product_Type.Pair $ BOUND 0 $ BOUND 1 ) ) $ ( CONST Product_Type.Pair $ BOUND 0 $ BOUND 1 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.quotient_of $ BOUND 2 ) $ ( CONST Product_Type.Pair $ BOUND 1 $ BOUND 0 ) ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 2 $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Rat.rat_of_int $ BOUND 1 ) $ ( CONST Rat.rat_of_int $ BOUND 0 ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.field_char_0_class.of_rat $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Rat.field_char_0_class.of_rat $ BOUND 1 ) $ ( CONST Rat.field_char_0_class.of_rat $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.quotient_of $ ( CONST Rat.Fract $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Rat.normalize $ ( CONST Product_Type.Pair $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.field_char_0_class.of_rat $ ( CONST Rat.rat_of_int $ BOUND 0 ) ) $ ( CONST Int.ring_1_class.of_int $ BOUND 0 ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ CONST Rat.field_char_0_class.Rats $ ( CONST Set.range $ CONST Rat.field_char_0_class.of_rat ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;b f A thesis.
   \&lt;lbrakk&gt;b \&lt;in&gt; f ` A;
    \&lt;And&gt;x.
       \&lt;lbrakk&gt;b = f x; x \&lt;in&gt; A\&lt;rbrakk&gt;
       \&lt;Longrightarrow&gt; thesis\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; thesis &lt;SEP&gt; \&lt;And&gt;q C.
   (\&lt;And&gt;a b.
       \&lt;lbrakk&gt;q = Fract a b; 0 &lt; b; coprime a b\&lt;rbrakk&gt;
       \&lt;Longrightarrow&gt; C) \&lt;Longrightarrow&gt;
   C &lt;SEP&gt; \&lt;And&gt;q p.
   \&lt;lbrakk&gt;0 &lt; q; coprime p q\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; Rat.normalize (p, q) = (p, q) &lt;SEP&gt; \&lt;And&gt;r n d.
   quotient_of r = (n, d) \&lt;Longrightarrow&gt; r = rat_of_int n / rat_of_int d &lt;SEP&gt; \&lt;And&gt;a b. quotient_of (Fract a b) = Rat.normalize (a, b) &lt;SEP&gt; \&lt;And&gt;a b. of_rat (a / b) = of_rat a / of_rat b &lt;SEP&gt; \&lt;And&gt;z. of_rat (rat_of_int z) = of_int z &lt;SEP&gt; \&lt;rat&gt; = range of_rat</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}b\ f\ A\ thesis{\isachardot}\ {\isasymlbrakk}b\ {\isasymin}\ f\ {\isacharbackquote}\ A{\isacharsemicolon}\ {\isasymAnd}x{\isachardot}\ {\isasymlbrakk}b\ {\isacharequal}\ f\ x{\isacharsemicolon}\ x\ {\isasymin}\ A{\isasymrbrakk}\ {\isasymLongrightarrow}\ thesis{\isasymrbrakk}\ {\isasymLongrightarrow}\ thesis\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}q\ p{\isachardot}\ {\isasymlbrakk}{\isadigit{0}}\ {\isacharless}\ q{\isacharsemicolon}\ coprime\ p\ q{\isasymrbrakk}\ {\isasymLongrightarrow}\ Rat{\isachardot}normalize\ {\isacharparenleft}p{\isacharcomma}\ q{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}p{\isacharcomma}\ q{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}r\ n\ d{\isachardot}\ quotient{\isacharunderscore}of\ r\ {\isacharequal}\ {\isacharparenleft}n{\isacharcomma}\ d{\isacharparenright}\ {\isasymLongrightarrow}\ r\ {\isacharequal}\ rat{\isacharunderscore}of{\isacharunderscore}int\ n\ {\isacharslash}\ rat{\isacharunderscore}of{\isacharunderscore}int\ d\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}q\ C{\isachardot}\ {\isacharparenleft}{\isasymAnd}a\ b{\isachardot}\ {\isasymlbrakk}q\ {\isacharequal}\ Fract\ a\ b{\isacharsemicolon}\ {\isadigit{0}}\ {\isacharless}\ b{\isacharsemicolon}\ coprime\ a\ b{\isasymrbrakk}\ {\isasymLongrightarrow}\ C{\isacharparenright}\ {\isasymLongrightarrow}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ quotient{\isacharunderscore}of\ {\isacharparenleft}Fract\ a\ b{\isacharparenright}\ {\isacharequal}\ Rat{\isachardot}normalize\ {\isacharparenleft}a{\isacharcomma}\ b{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ of{\isacharunderscore}rat\ {\isacharparenleft}a\ {\isacharslash}\ b{\isacharparenright}\ {\isacharequal}\ of{\isacharunderscore}rat\ a\ {\isacharslash}\ of{\isacharunderscore}rat\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}z{\isachardot}\ of{\isacharunderscore}rat\ {\isacharparenleft}rat{\isacharunderscore}of{\isacharunderscore}int\ z{\isacharparenright}\ {\isacharequal}\ of{\isacharunderscore}int\ z\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymrat}\ {\isacharequal}\ range\ of{\isacharunderscore}rat\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) ) $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) ) )</consequences>
      <consequences_ascii>2 = real_of_int (&lt;X0&gt;\&lt;^sup&gt;2) / real_of_int (&lt;X1&gt;\&lt;^sup&gt;2)</consequences_ascii>
      <consequences_ascii_original>2 = real_of_int (a\&lt;^sup&gt;2) / real_of_int (b\&lt;^sup&gt;2)</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}a\isactrlsup {\isadigit{2}}{\isacharparenright}\ {\isacharslash}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}b\isactrlsup {\isadigit{2}}{\isacharparenright}\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; )  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 2 $ BOUND 1 ) $ BOUND 0 ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Power.power_class.power $ BOUND 2 $ BOUND 0 ) $ ( CONST Power.power_class.power $ BOUND 1 $ BOUND 0 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Int.ring_1_class.of_int $ ( CONST Power.power_class.power $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Power.power_class.power $ ( CONST Int.ring_1_class.of_int $ BOUND 1 ) $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less_eq $ CONST Groups.zero_class.zero $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ ( CONST NthRoot.sqrt $ BOUND 0 ) ) $ BOUND 0 ) ) )</consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; coprime a b  &lt;SEP&gt; \&lt;And&gt;x. 0 \&lt;le&gt; x \&lt;Longrightarrow&gt; (sqrt x)\&lt;^sup&gt;2 = x &lt;SEP&gt; \&lt;And&gt;z n. of_int (z ^ n) = of_int z ^ n &lt;SEP&gt; \&lt;And&gt;a b n. (a / b) ^ n = a ^ n / b ^ n</consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt;  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b\ n{\isachardot}\ {\isacharparenleft}a\ {\isacharslash}\ b{\isacharparenright}\isactrlbsup n\isactrlesup \ {\isacharequal}\ a\isactrlbsup n\isactrlesup \ {\isacharslash}\ b\isactrlbsup n\isactrlesup \&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}z\ n{\isachardot}\ of{\isacharunderscore}int\ z\isactrlbsup n\isactrlesup \ {\isacharequal}\ {\isacharparenleft}of{\isacharunderscore}int\ z{\isacharparenright}\isactrlbsup n\isactrlesup \&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}x{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ x\ {\isasymLongrightarrow}\ {\isacharparenleft}sqrt\ x{\isacharparenright}\isactrlsup {\isadigit{2}}\ {\isacharequal}\ x\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>coprime &lt;X0&gt; &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>coprime a b</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Set.member $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ CONST Rat.field_char_0_class.Rats )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; sqrt 2 \&lt;in&gt; \&lt;rat&gt;</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isasymin}\ {\isasymrat}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Set.member $ BOUND 3 $ ( CONST Set.image $ ( ABS BOUND 3 $ BOUND 0 ) $ BOUND 1 ) ) ) $ ( CONST Pure.imp $ ( CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 4 $ ( BOUND 3 $ BOUND 0 ) ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Set.member $ BOUND 0 $ BOUND 2 ) ) $ ( CONST HOL.Trueprop $ BOUND 1 ) ) ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 3 $ ( CONST Rat.Fract $ BOUND 1 $ BOUND 0 ) ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less $ CONST Groups.zero_class.zero $ BOUND 0 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 2 ) ) ) ) ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less $ CONST Groups.zero_class.zero $ BOUND 1 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ BOUND 0 $ BOUND 1 ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.normalize $ ( CONST Product_Type.Pair $ BOUND 0 $ BOUND 1 ) ) $ ( CONST Product_Type.Pair $ BOUND 0 $ BOUND 1 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.quotient_of $ BOUND 2 ) $ ( CONST Product_Type.Pair $ BOUND 1 $ BOUND 0 ) ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 2 $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Rat.rat_of_int $ BOUND 1 ) $ ( CONST Rat.rat_of_int $ BOUND 0 ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.field_char_0_class.of_rat $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Rat.field_char_0_class.of_rat $ BOUND 1 ) $ ( CONST Rat.field_char_0_class.of_rat $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.quotient_of $ ( CONST Rat.Fract $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Rat.normalize $ ( CONST Product_Type.Pair $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.field_char_0_class.of_rat $ ( CONST Rat.rat_of_int $ BOUND 0 ) ) $ ( CONST Int.ring_1_class.of_int $ BOUND 0 ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ CONST Rat.field_char_0_class.Rats $ ( CONST Set.range $ CONST Rat.field_char_0_class.of_rat ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;b f A thesis.
   \&lt;lbrakk&gt;b \&lt;in&gt; f ` A;
    \&lt;And&gt;x.
       \&lt;lbrakk&gt;b = f x; x \&lt;in&gt; A\&lt;rbrakk&gt;
       \&lt;Longrightarrow&gt; thesis\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; thesis &lt;SEP&gt; \&lt;And&gt;q C.
   (\&lt;And&gt;a b.
       \&lt;lbrakk&gt;q = Fract a b; 0 &lt; b; coprime a b\&lt;rbrakk&gt;
       \&lt;Longrightarrow&gt; C) \&lt;Longrightarrow&gt;
   C &lt;SEP&gt; \&lt;And&gt;q p.
   \&lt;lbrakk&gt;0 &lt; q; coprime p q\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; Rat.normalize (p, q) = (p, q) &lt;SEP&gt; \&lt;And&gt;r n d.
   quotient_of r = (n, d) \&lt;Longrightarrow&gt; r = rat_of_int n / rat_of_int d &lt;SEP&gt; \&lt;And&gt;a b. quotient_of (Fract a b) = Rat.normalize (a, b) &lt;SEP&gt; \&lt;And&gt;a b. of_rat (a / b) = of_rat a / of_rat b &lt;SEP&gt; \&lt;And&gt;z. of_rat (rat_of_int z) = of_int z &lt;SEP&gt; \&lt;rat&gt; = range of_rat</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}b\ f\ A\ thesis{\isachardot}\ {\isasymlbrakk}b\ {\isasymin}\ f\ {\isacharbackquote}\ A{\isacharsemicolon}\ {\isasymAnd}x{\isachardot}\ {\isasymlbrakk}b\ {\isacharequal}\ f\ x{\isacharsemicolon}\ x\ {\isasymin}\ A{\isasymrbrakk}\ {\isasymLongrightarrow}\ thesis{\isasymrbrakk}\ {\isasymLongrightarrow}\ thesis\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}q\ p{\isachardot}\ {\isasymlbrakk}{\isadigit{0}}\ {\isacharless}\ q{\isacharsemicolon}\ coprime\ p\ q{\isasymrbrakk}\ {\isasymLongrightarrow}\ Rat{\isachardot}normalize\ {\isacharparenleft}p{\isacharcomma}\ q{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}p{\isacharcomma}\ q{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}r\ n\ d{\isachardot}\ quotient{\isacharunderscore}of\ r\ {\isacharequal}\ {\isacharparenleft}n{\isacharcomma}\ d{\isacharparenright}\ {\isasymLongrightarrow}\ r\ {\isacharequal}\ rat{\isacharunderscore}of{\isacharunderscore}int\ n\ {\isacharslash}\ rat{\isacharunderscore}of{\isacharunderscore}int\ d\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}q\ C{\isachardot}\ {\isacharparenleft}{\isasymAnd}a\ b{\isachardot}\ {\isasymlbrakk}q\ {\isacharequal}\ Fract\ a\ b{\isacharsemicolon}\ {\isadigit{0}}\ {\isacharless}\ b{\isacharsemicolon}\ coprime\ a\ b{\isasymrbrakk}\ {\isasymLongrightarrow}\ C{\isacharparenright}\ {\isasymLongrightarrow}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ quotient{\isacharunderscore}of\ {\isacharparenleft}Fract\ a\ b{\isacharparenright}\ {\isacharequal}\ Rat{\isachardot}normalize\ {\isacharparenleft}a{\isacharcomma}\ b{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ of{\isacharunderscore}rat\ {\isacharparenleft}a\ {\isacharslash}\ b{\isacharparenright}\ {\isacharequal}\ of{\isacharunderscore}rat\ a\ {\isacharslash}\ of{\isacharunderscore}rat\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}z{\isachardot}\ of{\isacharunderscore}rat\ {\isacharparenleft}rat{\isacharunderscore}of{\isacharunderscore}int\ z{\isacharparenright}\ {\isacharequal}\ of{\isacharunderscore}int\ z\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymrat}\ {\isacharequal}\ range\ of{\isacharunderscore}rat\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) ) $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) ) )</consequences>
      <consequences_ascii>2 = real_of_int (&lt;X0&gt;\&lt;^sup&gt;2) / real_of_int (&lt;X1&gt;\&lt;^sup&gt;2)</consequences_ascii>
      <consequences_ascii_original>2 = real_of_int (a\&lt;^sup&gt;2) / real_of_int (b\&lt;^sup&gt;2)</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}a\isactrlsup {\isadigit{2}}{\isacharparenright}\ {\isacharslash}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}b\isactrlsup {\isadigit{2}}{\isacharparenright}\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Real.real_of_int $ FREE &lt;X0&gt; ) $ ( CONST Real.real_of_int $ FREE &lt;X1&gt; ) ) )  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 2 $ BOUND 1 ) $ BOUND 0 ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Power.power_class.power $ BOUND 2 $ BOUND 0 ) $ ( CONST Power.power_class.power $ BOUND 1 $ BOUND 0 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Int.ring_1_class.of_int $ ( CONST Power.power_class.power $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Power.power_class.power $ ( CONST Int.ring_1_class.of_int $ BOUND 1 ) $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less_eq $ CONST Groups.zero_class.zero $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ ( CONST NthRoot.sqrt $ BOUND 0 ) ) $ BOUND 0 ) ) )</consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; sqrt 2 = real_of_int a / real_of_int b  &lt;SEP&gt; \&lt;And&gt;x. 0 \&lt;le&gt; x \&lt;Longrightarrow&gt; (sqrt x)\&lt;^sup&gt;2 = x &lt;SEP&gt; \&lt;And&gt;z n. of_int (z ^ n) = of_int z ^ n &lt;SEP&gt; \&lt;And&gt;a b n. (a / b) ^ n = a ^ n / b ^ n</consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ a\ {\isacharslash}\ real{\isacharunderscore}of{\isacharunderscore}int\ b\&lt;close&gt;  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b\ n{\isachardot}\ {\isacharparenleft}a\ {\isacharslash}\ b{\isacharparenright}\isactrlbsup n\isactrlesup \ {\isacharequal}\ a\isactrlbsup n\isactrlesup \ {\isacharslash}\ b\isactrlbsup n\isactrlesup \&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}z\ n{\isachardot}\ of{\isacharunderscore}int\ z\isactrlbsup n\isactrlesup \ {\isacharequal}\ {\isacharparenleft}of{\isacharunderscore}int\ z{\isacharparenright}\isactrlbsup n\isactrlesup \&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}x{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ x\ {\isasymLongrightarrow}\ {\isacharparenleft}sqrt\ x{\isacharparenright}\isactrlsup {\isadigit{2}}\ {\isacharequal}\ x\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[8]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>coprime &lt;X0&gt; &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>coprime a b</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Set.member $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ CONST Rat.field_char_0_class.Rats )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; sqrt 2 \&lt;in&gt; \&lt;rat&gt;</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isasymin}\ {\isasymrat}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Set.member $ BOUND 3 $ ( CONST Set.image $ ( ABS BOUND 3 $ BOUND 0 ) $ BOUND 1 ) ) ) $ ( CONST Pure.imp $ ( CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 4 $ ( BOUND 3 $ BOUND 0 ) ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Set.member $ BOUND 0 $ BOUND 2 ) ) $ ( CONST HOL.Trueprop $ BOUND 1 ) ) ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 3 $ ( CONST Rat.Fract $ BOUND 1 $ BOUND 0 ) ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less $ CONST Groups.zero_class.zero $ BOUND 0 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 2 ) ) ) ) ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less $ CONST Groups.zero_class.zero $ BOUND 1 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ BOUND 0 $ BOUND 1 ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.normalize $ ( CONST Product_Type.Pair $ BOUND 0 $ BOUND 1 ) ) $ ( CONST Product_Type.Pair $ BOUND 0 $ BOUND 1 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.quotient_of $ BOUND 2 ) $ ( CONST Product_Type.Pair $ BOUND 1 $ BOUND 0 ) ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 2 $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Rat.rat_of_int $ BOUND 1 ) $ ( CONST Rat.rat_of_int $ BOUND 0 ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.field_char_0_class.of_rat $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Rat.field_char_0_class.of_rat $ BOUND 1 ) $ ( CONST Rat.field_char_0_class.of_rat $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.quotient_of $ ( CONST Rat.Fract $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Rat.normalize $ ( CONST Product_Type.Pair $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.field_char_0_class.of_rat $ ( CONST Rat.rat_of_int $ BOUND 0 ) ) $ ( CONST Int.ring_1_class.of_int $ BOUND 0 ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ CONST Rat.field_char_0_class.Rats $ ( CONST Set.range $ CONST Rat.field_char_0_class.of_rat ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;b f A thesis.
   \&lt;lbrakk&gt;b \&lt;in&gt; f ` A;
    \&lt;And&gt;x.
       \&lt;lbrakk&gt;b = f x; x \&lt;in&gt; A\&lt;rbrakk&gt;
       \&lt;Longrightarrow&gt; thesis\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; thesis &lt;SEP&gt; \&lt;And&gt;q C.
   (\&lt;And&gt;a b.
       \&lt;lbrakk&gt;q = Fract a b; 0 &lt; b; coprime a b\&lt;rbrakk&gt;
       \&lt;Longrightarrow&gt; C) \&lt;Longrightarrow&gt;
   C &lt;SEP&gt; \&lt;And&gt;q p.
   \&lt;lbrakk&gt;0 &lt; q; coprime p q\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; Rat.normalize (p, q) = (p, q) &lt;SEP&gt; \&lt;And&gt;r n d.
   quotient_of r = (n, d) \&lt;Longrightarrow&gt; r = rat_of_int n / rat_of_int d &lt;SEP&gt; \&lt;And&gt;a b. quotient_of (Fract a b) = Rat.normalize (a, b) &lt;SEP&gt; \&lt;And&gt;a b. of_rat (a / b) = of_rat a / of_rat b &lt;SEP&gt; \&lt;And&gt;z. of_rat (rat_of_int z) = of_int z &lt;SEP&gt; \&lt;rat&gt; = range of_rat</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}b\ f\ A\ thesis{\isachardot}\ {\isasymlbrakk}b\ {\isasymin}\ f\ {\isacharbackquote}\ A{\isacharsemicolon}\ {\isasymAnd}x{\isachardot}\ {\isasymlbrakk}b\ {\isacharequal}\ f\ x{\isacharsemicolon}\ x\ {\isasymin}\ A{\isasymrbrakk}\ {\isasymLongrightarrow}\ thesis{\isasymrbrakk}\ {\isasymLongrightarrow}\ thesis\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}q\ p{\isachardot}\ {\isasymlbrakk}{\isadigit{0}}\ {\isacharless}\ q{\isacharsemicolon}\ coprime\ p\ q{\isasymrbrakk}\ {\isasymLongrightarrow}\ Rat{\isachardot}normalize\ {\isacharparenleft}p{\isacharcomma}\ q{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}p{\isacharcomma}\ q{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}r\ n\ d{\isachardot}\ quotient{\isacharunderscore}of\ r\ {\isacharequal}\ {\isacharparenleft}n{\isacharcomma}\ d{\isacharparenright}\ {\isasymLongrightarrow}\ r\ {\isacharequal}\ rat{\isacharunderscore}of{\isacharunderscore}int\ n\ {\isacharslash}\ rat{\isacharunderscore}of{\isacharunderscore}int\ d\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}q\ C{\isachardot}\ {\isacharparenleft}{\isasymAnd}a\ b{\isachardot}\ {\isasymlbrakk}q\ {\isacharequal}\ Fract\ a\ b{\isacharsemicolon}\ {\isadigit{0}}\ {\isacharless}\ b{\isacharsemicolon}\ coprime\ a\ b{\isasymrbrakk}\ {\isasymLongrightarrow}\ C{\isacharparenright}\ {\isasymLongrightarrow}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ quotient{\isacharunderscore}of\ {\isacharparenleft}Fract\ a\ b{\isacharparenright}\ {\isacharequal}\ Rat{\isachardot}normalize\ {\isacharparenleft}a{\isacharcomma}\ b{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ of{\isacharunderscore}rat\ {\isacharparenleft}a\ {\isacharslash}\ b{\isacharparenright}\ {\isacharequal}\ of{\isacharunderscore}rat\ a\ {\isacharslash}\ of{\isacharunderscore}rat\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}z{\isachardot}\ of{\isacharunderscore}rat\ {\isacharparenleft}rat{\isacharunderscore}of{\isacharunderscore}int\ z{\isacharparenright}\ {\isacharequal}\ of{\isacharunderscore}int\ z\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymrat}\ {\isacharequal}\ range\ of{\isacharunderscore}rat\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ CONST HOL.False</consequences>
      <consequences_ascii>False</consequences_ascii>
      <consequences_ascii_original>False</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;False\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X1&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; even a &lt;SEP&gt; even a &lt;SEP&gt; even b </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ b\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[8]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>coprime &lt;X0&gt; &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>coprime a b</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Set.member $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ CONST Rat.field_char_0_class.Rats )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; sqrt 2 \&lt;in&gt; \&lt;rat&gt;</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isasymin}\ {\isasymrat}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Set.member $ BOUND 3 $ ( CONST Set.image $ ( ABS BOUND 3 $ BOUND 0 ) $ BOUND 1 ) ) ) $ ( CONST Pure.imp $ ( CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 4 $ ( BOUND 3 $ BOUND 0 ) ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Set.member $ BOUND 0 $ BOUND 2 ) ) $ ( CONST HOL.Trueprop $ BOUND 1 ) ) ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 3 $ ( CONST Rat.Fract $ BOUND 1 $ BOUND 0 ) ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less $ CONST Groups.zero_class.zero $ BOUND 0 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 2 ) ) ) ) ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less $ CONST Groups.zero_class.zero $ BOUND 1 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ BOUND 0 $ BOUND 1 ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.normalize $ ( CONST Product_Type.Pair $ BOUND 0 $ BOUND 1 ) ) $ ( CONST Product_Type.Pair $ BOUND 0 $ BOUND 1 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.quotient_of $ BOUND 2 ) $ ( CONST Product_Type.Pair $ BOUND 1 $ BOUND 0 ) ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 2 $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Rat.rat_of_int $ BOUND 1 ) $ ( CONST Rat.rat_of_int $ BOUND 0 ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.field_char_0_class.of_rat $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Rat.field_char_0_class.of_rat $ BOUND 1 ) $ ( CONST Rat.field_char_0_class.of_rat $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.quotient_of $ ( CONST Rat.Fract $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Rat.normalize $ ( CONST Product_Type.Pair $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rat.field_char_0_class.of_rat $ ( CONST Rat.rat_of_int $ BOUND 0 ) ) $ ( CONST Int.ring_1_class.of_int $ BOUND 0 ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ CONST Rat.field_char_0_class.Rats $ ( CONST Set.range $ CONST Rat.field_char_0_class.of_rat ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;b f A thesis.
   \&lt;lbrakk&gt;b \&lt;in&gt; f ` A;
    \&lt;And&gt;x.
       \&lt;lbrakk&gt;b = f x; x \&lt;in&gt; A\&lt;rbrakk&gt;
       \&lt;Longrightarrow&gt; thesis\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; thesis &lt;SEP&gt; \&lt;And&gt;q C.
   (\&lt;And&gt;a b.
       \&lt;lbrakk&gt;q = Fract a b; 0 &lt; b; coprime a b\&lt;rbrakk&gt;
       \&lt;Longrightarrow&gt; C) \&lt;Longrightarrow&gt;
   C &lt;SEP&gt; \&lt;And&gt;q p.
   \&lt;lbrakk&gt;0 &lt; q; coprime p q\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; Rat.normalize (p, q) = (p, q) &lt;SEP&gt; \&lt;And&gt;r n d.
   quotient_of r = (n, d) \&lt;Longrightarrow&gt; r = rat_of_int n / rat_of_int d &lt;SEP&gt; \&lt;And&gt;a b. quotient_of (Fract a b) = Rat.normalize (a, b) &lt;SEP&gt; \&lt;And&gt;a b. of_rat (a / b) = of_rat a / of_rat b &lt;SEP&gt; \&lt;And&gt;z. of_rat (rat_of_int z) = of_int z &lt;SEP&gt; \&lt;rat&gt; = range of_rat</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}b\ f\ A\ thesis{\isachardot}\ {\isasymlbrakk}b\ {\isasymin}\ f\ {\isacharbackquote}\ A{\isacharsemicolon}\ {\isasymAnd}x{\isachardot}\ {\isasymlbrakk}b\ {\isacharequal}\ f\ x{\isacharsemicolon}\ x\ {\isasymin}\ A{\isasymrbrakk}\ {\isasymLongrightarrow}\ thesis{\isasymrbrakk}\ {\isasymLongrightarrow}\ thesis\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}q\ p{\isachardot}\ {\isasymlbrakk}{\isadigit{0}}\ {\isacharless}\ q{\isacharsemicolon}\ coprime\ p\ q{\isasymrbrakk}\ {\isasymLongrightarrow}\ Rat{\isachardot}normalize\ {\isacharparenleft}p{\isacharcomma}\ q{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}p{\isacharcomma}\ q{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}r\ n\ d{\isachardot}\ quotient{\isacharunderscore}of\ r\ {\isacharequal}\ {\isacharparenleft}n{\isacharcomma}\ d{\isacharparenright}\ {\isasymLongrightarrow}\ r\ {\isacharequal}\ rat{\isacharunderscore}of{\isacharunderscore}int\ n\ {\isacharslash}\ rat{\isacharunderscore}of{\isacharunderscore}int\ d\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}q\ C{\isachardot}\ {\isacharparenleft}{\isasymAnd}a\ b{\isachardot}\ {\isasymlbrakk}q\ {\isacharequal}\ Fract\ a\ b{\isacharsemicolon}\ {\isadigit{0}}\ {\isacharless}\ b{\isacharsemicolon}\ coprime\ a\ b{\isasymrbrakk}\ {\isasymLongrightarrow}\ C{\isacharparenright}\ {\isasymLongrightarrow}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ quotient{\isacharunderscore}of\ {\isacharparenleft}Fract\ a\ b{\isacharparenright}\ {\isacharequal}\ Rat{\isachardot}normalize\ {\isacharparenleft}a{\isacharcomma}\ b{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ of{\isacharunderscore}rat\ {\isacharparenleft}a\ {\isacharslash}\ b{\isacharparenright}\ {\isacharequal}\ of{\isacharunderscore}rat\ a\ {\isacharslash}\ of{\isacharunderscore}rat\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}z{\isachardot}\ of{\isacharunderscore}rat\ {\isacharparenleft}rat{\isacharunderscore}of{\isacharunderscore}int\ z{\isacharparenright}\ {\isacharequal}\ of{\isacharunderscore}int\ z\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymrat}\ {\isacharequal}\ range\ of{\isacharunderscore}rat\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ CONST HOL.False</consequences>
      <consequences_ascii>False</consequences_ascii>
      <consequences_ascii_original>False</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;False\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X1&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; even a &lt;SEP&gt; even a &lt;SEP&gt; even b </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ b\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[2]" location_in_theorem_consequence="[3]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) ) $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) ) )</target_fact>
      <target_fact_ascii>2 = real_of_int (&lt;X0&gt;\&lt;^sup&gt;2) / real_of_int (&lt;X1&gt;\&lt;^sup&gt;2)</target_fact_ascii>
      <target_fact_ascii_original>2 = real_of_int (a\&lt;^sup&gt;2) / real_of_int (b\&lt;^sup&gt;2)</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}a\isactrlsup {\isadigit{2}}{\isacharparenright}\ {\isacharslash}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}b\isactrlsup {\isadigit{2}}{\isacharparenright}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST NthRoot.sqrt $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Real.real_of_int $ FREE &lt;X0&gt; ) $ ( CONST Real.real_of_int $ FREE &lt;X1&gt; ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; sqrt 2 = real_of_int a / real_of_int b &lt;SEP&gt; coprime a b</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;sqrt\ {\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ a\ {\isacharslash}\ real{\isacharunderscore}of{\isacharunderscore}int\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 2 $ BOUND 1 ) $ BOUND 0 ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Power.power_class.power $ BOUND 2 $ BOUND 0 ) $ ( CONST Power.power_class.power $ BOUND 1 $ BOUND 0 ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Int.ring_1_class.of_int $ ( CONST Power.power_class.power $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Power.power_class.power $ ( CONST Int.ring_1_class.of_int $ BOUND 1 ) $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Orderings.ord_class.less_eq $ CONST Groups.zero_class.zero $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ ( CONST NthRoot.sqrt $ BOUND 0 ) ) $ BOUND 0 ) ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;x. 0 \&lt;le&gt; x \&lt;Longrightarrow&gt; (sqrt x)\&lt;^sup&gt;2 = x &lt;SEP&gt; \&lt;And&gt;z n. of_int (z ^ n) = of_int z ^ n &lt;SEP&gt; \&lt;And&gt;a b n. (a / b) ^ n = a ^ n / b ^ n</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b\ n{\isachardot}\ {\isacharparenleft}a\ {\isacharslash}\ b{\isacharparenright}\isactrlbsup n\isactrlesup \ {\isacharequal}\ a\isactrlbsup n\isactrlesup \ {\isacharslash}\ b\isactrlbsup n\isactrlesup \&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}z\ n{\isachardot}\ of{\isacharunderscore}int\ z\isactrlbsup n\isactrlesup \ {\isacharequal}\ {\isacharparenleft}of{\isacharunderscore}int\ z{\isacharparenright}\isactrlbsup n\isactrlesup \&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}x{\isachardot}\ {\isadigit{0}}\ {\isasymle}\ x\ {\isasymLongrightarrow}\ {\isacharparenleft}sqrt\ x{\isacharparenright}\isactrlsup {\isadigit{2}}\ {\isacharequal}\ x\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) )</consequences>
      <consequences_ascii>2 * &lt;X1&gt;\&lt;^sup&gt;2 = &lt;X0&gt;\&lt;^sup&gt;2</consequences_ascii>
      <consequences_ascii_original>2 * b\&lt;^sup&gt;2 = a\&lt;^sup&gt;2</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharasterisk}\ b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\isactrlsup {\isadigit{2}}\&lt;close&gt;</consequences_latex>
      <consequences_others>  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ BOUND 2 $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Groups.times_class.times $ BOUND 2 $ BOUND 1 ) $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.not_equal $ BOUND 1 $ CONST Groups.zero_class.zero ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rings.divide_class.divide $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) $ BOUND 1 ) $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 0 $ CONST Groups.zero_class.zero ) $ CONST Groups.zero_class.zero ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST Groups.zero_class.zero $ ( CONST Num.numeral_class.numeral $ BOUND 0 ) ) )</consequences_others>
      <consequences_others_ascii_original>  &lt;SEP&gt; \&lt;And&gt;a b. a \&lt;noteq&gt; (0::?'a) \&lt;Longrightarrow&gt; a * b div a = b &lt;SEP&gt; \&lt;And&gt;n. (0::?'a) \&lt;noteq&gt; numeral n &lt;SEP&gt; \&lt;And&gt;a b c. a * (b / c) = a * b / c &lt;SEP&gt; \&lt;And&gt;a. a / (0::?'a) = (0::?'a)</consequences_others_ascii_original>
      <consequences_others_latex>  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ a\ {\isacharslash}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ a\ {\isasymnoteq}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isasymLongrightarrow}\ a\ {\isacharasterisk}\ b\ div\ a\ {\isacharequal}\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b\ c{\isachardot}\ a\ {\isacharasterisk}\ {\isacharparenleft}b\ {\isacharslash}\ c{\isacharparenright}\ {\isacharequal}\ a\ {\isacharasterisk}\ b\ {\isacharslash}\ c\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}n{\isachardot}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isasymnoteq}\ numeral\ n\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[3,0]" location_in_theorem_consequence="[3,1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) ) $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) ) )</target_fact>
      <target_fact_ascii>2 = real_of_int (&lt;X0&gt;\&lt;^sup&gt;2) / real_of_int (&lt;X1&gt;\&lt;^sup&gt;2)</target_fact_ascii>
      <target_fact_ascii_original>2 = real_of_int (a\&lt;^sup&gt;2) / real_of_int (b\&lt;^sup&gt;2)</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}a\isactrlsup {\isadigit{2}}{\isacharparenright}\ {\isacharslash}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}b\isactrlsup {\isadigit{2}}{\isacharparenright}\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) ) )</consequences>
      <consequences_ascii>real_of_int (&lt;X1&gt;\&lt;^sup&gt;2) * 2 = real_of_int (&lt;X0&gt;\&lt;^sup&gt;2)</consequences_ascii>
      <consequences_ascii_original>real_of_int (b\&lt;^sup&gt;2) * 2 = real_of_int (a\&lt;^sup&gt;2)</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}b\isactrlsup {\isadigit{2}}{\isacharparenright}\ {\isacharasterisk}\ {\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}a\isactrlsup {\isadigit{2}}{\isacharparenright}\&lt;close&gt;</consequences_latex>
      <consequences_others>  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ BOUND 2 $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Groups.times_class.times $ BOUND 2 $ BOUND 1 ) $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.not_equal $ BOUND 1 $ CONST Groups.zero_class.zero ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rings.divide_class.divide $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) $ BOUND 1 ) $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 0 $ CONST Groups.zero_class.zero ) $ CONST Groups.zero_class.zero ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST Groups.zero_class.zero $ ( CONST Num.numeral_class.numeral $ BOUND 0 ) ) )</consequences_others>
      <consequences_others_ascii_original>  &lt;SEP&gt; \&lt;And&gt;a b. a \&lt;noteq&gt; (0::?'a) \&lt;Longrightarrow&gt; a * b div a = b &lt;SEP&gt; \&lt;And&gt;n. (0::?'a) \&lt;noteq&gt; numeral n &lt;SEP&gt; \&lt;And&gt;a b c. a * (b / c) = a * b / c &lt;SEP&gt; \&lt;And&gt;a. a / (0::?'a) = (0::?'a)</consequences_others_ascii_original>
      <consequences_others_latex>  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ a\ {\isacharslash}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ a\ {\isasymnoteq}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isasymLongrightarrow}\ a\ {\isacharasterisk}\ b\ div\ a\ {\isacharequal}\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b\ c{\isachardot}\ a\ {\isacharasterisk}\ {\isacharparenleft}b\ {\isacharslash}\ c{\isacharparenright}\ {\isacharequal}\ a\ {\isacharasterisk}\ b\ {\isacharslash}\ c\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}n{\isachardot}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isasymnoteq}\ numeral\ n\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[3]" location_in_theorem_consequence="[4]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) )</target_fact>
      <target_fact_ascii>2 * &lt;X1&gt;\&lt;^sup&gt;2 = &lt;X0&gt;\&lt;^sup&gt;2</target_fact_ascii>
      <target_fact_ascii_original>2 * b\&lt;^sup&gt;2 = a\&lt;^sup&gt;2</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharasterisk}\ b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\isactrlsup {\isadigit{2}}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) ) $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; 2 = real_of_int (a\&lt;^sup&gt;2) / real_of_int (b\&lt;^sup&gt;2)</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}a\isactrlsup {\isadigit{2}}{\isacharparenright}\ {\isacharslash}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}b\isactrlsup {\isadigit{2}}{\isacharparenright}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ BOUND 2 $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Groups.times_class.times $ BOUND 2 $ BOUND 1 ) $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.not_equal $ BOUND 1 $ CONST Groups.zero_class.zero ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rings.divide_class.divide $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) $ BOUND 1 ) $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 0 $ CONST Groups.zero_class.zero ) $ CONST Groups.zero_class.zero ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST Groups.zero_class.zero $ ( CONST Num.numeral_class.numeral $ BOUND 0 ) ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;a b. a \&lt;noteq&gt; (0::?'a) \&lt;Longrightarrow&gt; a * b div a = b &lt;SEP&gt; \&lt;And&gt;n. (0::?'a) \&lt;noteq&gt; numeral n &lt;SEP&gt; \&lt;And&gt;a b c. a * (b / c) = a * b / c &lt;SEP&gt; \&lt;And&gt;a. a / (0::?'a) = (0::?'a)</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ a\ {\isacharslash}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ a\ {\isasymnoteq}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isasymLongrightarrow}\ a\ {\isacharasterisk}\ b\ div\ a\ {\isacharequal}\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b\ c{\isachardot}\ a\ {\isacharasterisk}\ {\isacharparenleft}b\ {\isacharslash}\ c{\isacharparenright}\ {\isacharequal}\ a\ {\isacharasterisk}\ b\ {\isacharslash}\ c\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}n{\isachardot}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isasymnoteq}\ numeral\ n\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; )</consequences>
      <consequences_ascii>even &lt;X0&gt;</consequences_ascii>
      <consequences_ascii_original>even a</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt;</consequences_latex>
      <consequences_others>  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Parity.semiring_parity_class.even $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.disj $ ( CONST Parity.semiring_parity_class.even $ BOUND 1 ) $ ( CONST Parity.semiring_parity_class.even $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST Rings.dvd_class.dvd $ BOUND 1 $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ BOUND 0 ) $ ( CONST Groups.times_class.times $ BOUND 0 $ BOUND 0 ) ) )</consequences_others>
      <consequences_others_ascii_original>  &lt;SEP&gt; \&lt;And&gt;a b. even (a * b) = (even a \&lt;or&gt; even b) &lt;SEP&gt; \&lt;And&gt;a. a\&lt;^sup&gt;2 = a * a &lt;SEP&gt; \&lt;And&gt;a b. a dvd a * b</consequences_others_ascii_original>
      <consequences_others_latex>  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ even\ {\isacharparenleft}a\ {\isacharasterisk}\ b{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}even\ a\ {\isasymor}\ even\ b{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ a\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\ {\isacharasterisk}\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ a\ dvd\ a\ {\isacharasterisk}\ b\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[3]" location_in_theorem_consequence="[6]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) )</target_fact>
      <target_fact_ascii>2 * &lt;X1&gt;\&lt;^sup&gt;2 = &lt;X0&gt;\&lt;^sup&gt;2</target_fact_ascii>
      <target_fact_ascii_original>2 * b\&lt;^sup&gt;2 = a\&lt;^sup&gt;2</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharasterisk}\ b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\isactrlsup {\isadigit{2}}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) ) $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; 2 = real_of_int (a\&lt;^sup&gt;2) / real_of_int (b\&lt;^sup&gt;2)</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}a\isactrlsup {\isadigit{2}}{\isacharparenright}\ {\isacharslash}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}b\isactrlsup {\isadigit{2}}{\isacharparenright}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ BOUND 2 $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Groups.times_class.times $ BOUND 2 $ BOUND 1 ) $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.not_equal $ BOUND 1 $ CONST Groups.zero_class.zero ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rings.divide_class.divide $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) $ BOUND 1 ) $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 0 $ CONST Groups.zero_class.zero ) $ CONST Groups.zero_class.zero ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST Groups.zero_class.zero $ ( CONST Num.numeral_class.numeral $ BOUND 0 ) ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;a b. a \&lt;noteq&gt; (0::?'a) \&lt;Longrightarrow&gt; a * b div a = b &lt;SEP&gt; \&lt;And&gt;n. (0::?'a) \&lt;noteq&gt; numeral n &lt;SEP&gt; \&lt;And&gt;a b c. a * (b / c) = a * b / c &lt;SEP&gt; \&lt;And&gt;a. a / (0::?'a) = (0::?'a)</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ a\ {\isacharslash}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ a\ {\isasymnoteq}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isasymLongrightarrow}\ a\ {\isacharasterisk}\ b\ div\ a\ {\isacharequal}\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b\ c{\isachardot}\ a\ {\isacharasterisk}\ {\isacharparenleft}b\ {\isacharslash}\ c{\isacharparenright}\ {\isacharequal}\ a\ {\isacharasterisk}\ b\ {\isacharslash}\ c\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}n{\isachardot}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isasymnoteq}\ numeral\ n\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X2&gt; ) ) )</consequences>
      <consequences_ascii>&lt;X1&gt;\&lt;^sup&gt;2 = 2 * &lt;X2&gt;\&lt;^sup&gt;2</consequences_ascii>
      <consequences_ascii_original>b\&lt;^sup&gt;2 = 2 * c\&lt;^sup&gt;2</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ {\isadigit{2}}\ {\isacharasterisk}\ c\isactrlsup {\isadigit{2}}\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ FREE &lt;X2&gt; ) ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; a = 2 * c </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;a\ {\isacharequal}\ {\isadigit{2}}\ {\isacharasterisk}\ c\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[3,2]" location_in_theorem_consequence="None" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) )</target_fact>
      <target_fact_ascii>2 * &lt;X1&gt;\&lt;^sup&gt;2 = &lt;X0&gt;\&lt;^sup&gt;2</target_fact_ascii>
      <target_fact_ascii_original>2 * b\&lt;^sup&gt;2 = a\&lt;^sup&gt;2</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharasterisk}\ b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\isactrlsup {\isadigit{2}}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; real_of_int (b\&lt;^sup&gt;2) * 2 = real_of_int (a\&lt;^sup&gt;2)</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}b\isactrlsup {\isadigit{2}}{\isacharparenright}\ {\isacharasterisk}\ {\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}a\isactrlsup {\isadigit{2}}{\isacharparenright}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[3,1]" location_in_theorem_consequence="[3,2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) ) )</target_fact>
      <target_fact_ascii>real_of_int (&lt;X1&gt;\&lt;^sup&gt;2) * 2 = real_of_int (&lt;X0&gt;\&lt;^sup&gt;2)</target_fact_ascii>
      <target_fact_ascii_original>real_of_int (b\&lt;^sup&gt;2) * 2 = real_of_int (a\&lt;^sup&gt;2)</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}b\isactrlsup {\isadigit{2}}{\isacharparenright}\ {\isacharasterisk}\ {\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}a\isactrlsup {\isadigit{2}}{\isacharparenright}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) ) $ ( CONST Real.real_of_int $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; 2 = real_of_int (a\&lt;^sup&gt;2) / real_of_int (b\&lt;^sup&gt;2)</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharequal}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}a\isactrlsup {\isadigit{2}}{\isacharparenright}\ {\isacharslash}\ real{\isacharunderscore}of{\isacharunderscore}int\ {\isacharparenleft}b\isactrlsup {\isadigit{2}}{\isacharparenright}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ BOUND 2 $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 1 $ BOUND 0 ) ) $ ( CONST Fields.inverse_class.inverse_divide $ ( CONST Groups.times_class.times $ BOUND 2 $ BOUND 1 ) $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.not_equal $ BOUND 1 $ CONST Groups.zero_class.zero ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Rings.divide_class.divide $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) $ BOUND 1 ) $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Fields.inverse_class.inverse_divide $ BOUND 0 $ CONST Groups.zero_class.zero ) $ CONST Groups.zero_class.zero ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST Groups.zero_class.zero $ ( CONST Num.numeral_class.numeral $ BOUND 0 ) ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;a b. a \&lt;noteq&gt; (0::?'a) \&lt;Longrightarrow&gt; a * b div a = b &lt;SEP&gt; \&lt;And&gt;n. (0::?'a) \&lt;noteq&gt; numeral n &lt;SEP&gt; \&lt;And&gt;a b c. a * (b / c) = a * b / c &lt;SEP&gt; \&lt;And&gt;a. a / (0::?'a) = (0::?'a)</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ a\ {\isacharslash}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ a\ {\isasymnoteq}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isasymLongrightarrow}\ a\ {\isacharasterisk}\ b\ div\ a\ {\isacharequal}\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b\ c{\isachardot}\ a\ {\isacharasterisk}\ {\isacharparenleft}b\ {\isacharslash}\ c{\isacharparenright}\ {\isacharequal}\ a\ {\isacharasterisk}\ b\ {\isacharslash}\ c\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}n{\isachardot}\ {\isacharparenleft}{\isadigit{0}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}a{\isacharparenright}\ {\isasymnoteq}\ numeral\ n\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) )</consequences>
      <consequences_ascii>2 * &lt;X1&gt;\&lt;^sup&gt;2 = &lt;X0&gt;\&lt;^sup&gt;2</consequences_ascii>
      <consequences_ascii_original>2 * b\&lt;^sup&gt;2 = a\&lt;^sup&gt;2</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharasterisk}\ b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\isactrlsup {\isadigit{2}}\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[4]" location_in_theorem_consequence="[5]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; )</target_fact>
      <target_fact_ascii>even &lt;X0&gt;</target_fact_ascii>
      <target_fact_ascii_original>even a</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; 2 * b\&lt;^sup&gt;2 = a\&lt;^sup&gt;2</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharasterisk}\ b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\isactrlsup {\isadigit{2}}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Parity.semiring_parity_class.even $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.disj $ ( CONST Parity.semiring_parity_class.even $ BOUND 1 ) $ ( CONST Parity.semiring_parity_class.even $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST Rings.dvd_class.dvd $ BOUND 1 $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ BOUND 0 ) $ ( CONST Groups.times_class.times $ BOUND 0 $ BOUND 0 ) ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;a b. even (a * b) = (even a \&lt;or&gt; even b) &lt;SEP&gt; \&lt;And&gt;a. a\&lt;^sup&gt;2 = a * a &lt;SEP&gt; \&lt;And&gt;a b. a dvd a * b</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ even\ {\isacharparenleft}a\ {\isacharasterisk}\ b{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}even\ a\ {\isasymor}\ even\ b{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ a\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\ {\isacharasterisk}\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ a\ dvd\ a\ {\isacharasterisk}\ b\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ FREE &lt;X2&gt; ) )</consequences>
      <consequences_ascii>&lt;X0&gt; = 2 * &lt;X2&gt;</consequences_ascii>
      <consequences_ascii_original>a = 2 * c</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;a\ {\isacharequal}\ {\isadigit{2}}\ {\isacharasterisk}\ c\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[4]" location_in_theorem_consequence="[8]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; )</target_fact>
      <target_fact_ascii>even &lt;X0&gt;</target_fact_ascii>
      <target_fact_ascii_original>even a</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; 2 * b\&lt;^sup&gt;2 = a\&lt;^sup&gt;2</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharasterisk}\ b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\isactrlsup {\isadigit{2}}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Parity.semiring_parity_class.even $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.disj $ ( CONST Parity.semiring_parity_class.even $ BOUND 1 ) $ ( CONST Parity.semiring_parity_class.even $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST Rings.dvd_class.dvd $ BOUND 1 $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ BOUND 0 ) $ ( CONST Groups.times_class.times $ BOUND 0 $ BOUND 0 ) ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;a b. even (a * b) = (even a \&lt;or&gt; even b) &lt;SEP&gt; \&lt;And&gt;a. a\&lt;^sup&gt;2 = a * a &lt;SEP&gt; \&lt;And&gt;a b. a dvd a * b</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ even\ {\isacharparenleft}a\ {\isacharasterisk}\ b{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}even\ a\ {\isasymor}\ even\ b{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ a\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\ {\isacharasterisk}\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ a\ dvd\ a\ {\isacharasterisk}\ b\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ CONST HOL.False</consequences>
      <consequences_ascii>False</consequences_ascii>
      <consequences_ascii_original>False</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;False\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X1&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; coprime a b &lt;SEP&gt; coprime a b &lt;SEP&gt; even b </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ b\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[4]" location_in_theorem_consequence="[8]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; )</target_fact>
      <target_fact_ascii>even &lt;X0&gt;</target_fact_ascii>
      <target_fact_ascii_original>even a</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; 2 * b\&lt;^sup&gt;2 = a\&lt;^sup&gt;2</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharasterisk}\ b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\isactrlsup {\isadigit{2}}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Parity.semiring_parity_class.even $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.disj $ ( CONST Parity.semiring_parity_class.even $ BOUND 1 ) $ ( CONST Parity.semiring_parity_class.even $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST Rings.dvd_class.dvd $ BOUND 1 $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ BOUND 0 ) $ ( CONST Groups.times_class.times $ BOUND 0 $ BOUND 0 ) ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;a b. even (a * b) = (even a \&lt;or&gt; even b) &lt;SEP&gt; \&lt;And&gt;a. a\&lt;^sup&gt;2 = a * a &lt;SEP&gt; \&lt;And&gt;a b. a dvd a * b</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ even\ {\isacharparenleft}a\ {\isacharasterisk}\ b{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}even\ a\ {\isasymor}\ even\ b{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ a\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\ {\isacharasterisk}\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ a\ dvd\ a\ {\isacharasterisk}\ b\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ CONST HOL.False</consequences>
      <consequences_ascii>False</consequences_ascii>
      <consequences_ascii_original>False</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;False\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X1&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; coprime a b &lt;SEP&gt; coprime a b &lt;SEP&gt; even b </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ b\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[5]" location_in_theorem_consequence="[6]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ FREE &lt;X2&gt; ) )</target_fact>
      <target_fact_ascii>&lt;X0&gt; = 2 * &lt;X2&gt;</target_fact_ascii>
      <target_fact_ascii_original>a = 2 * c</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;a\ {\isacharequal}\ {\isadigit{2}}\ {\isacharasterisk}\ c\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; even a</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X2&gt; ) ) )</consequences>
      <consequences_ascii>&lt;X1&gt;\&lt;^sup&gt;2 = 2 * &lt;X2&gt;\&lt;^sup&gt;2</consequences_ascii>
      <consequences_ascii_original>b\&lt;^sup&gt;2 = 2 * c\&lt;^sup&gt;2</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ {\isadigit{2}}\ {\isacharasterisk}\ c\isactrlsup {\isadigit{2}}\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; 2 * b\&lt;^sup&gt;2 = a\&lt;^sup&gt;2 </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharasterisk}\ b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\isactrlsup {\isadigit{2}}\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[6]" location_in_theorem_consequence="[7]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X2&gt; ) ) )</target_fact>
      <target_fact_ascii>&lt;X1&gt;\&lt;^sup&gt;2 = 2 * &lt;X2&gt;\&lt;^sup&gt;2</target_fact_ascii>
      <target_fact_ascii_original>b\&lt;^sup&gt;2 = 2 * c\&lt;^sup&gt;2</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ {\isadigit{2}}\ {\isacharasterisk}\ c\isactrlsup {\isadigit{2}}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X0&gt; ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ FREE &lt;X2&gt; ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; 2 * b\&lt;^sup&gt;2 = a\&lt;^sup&gt;2 &lt;SEP&gt; a = 2 * c</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isadigit{2}}\ {\isacharasterisk}\ b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\isactrlsup {\isadigit{2}}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;a\ {\isacharequal}\ {\isadigit{2}}\ {\isacharasterisk}\ c\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X1&gt; )</consequences>
      <consequences_ascii>even &lt;X1&gt;</consequences_ascii>
      <consequences_ascii_original>even b</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;even\ b\&lt;close&gt;</consequences_latex>
      <consequences_others>  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Parity.semiring_parity_class.even $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.disj $ ( CONST Parity.semiring_parity_class.even $ BOUND 1 ) $ ( CONST Parity.semiring_parity_class.even $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST Rings.dvd_class.dvd $ BOUND 1 $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ BOUND 0 ) $ ( CONST Groups.times_class.times $ BOUND 0 $ BOUND 0 ) ) )</consequences_others>
      <consequences_others_ascii_original>  &lt;SEP&gt; \&lt;And&gt;a b. even (a * b) = (even a \&lt;or&gt; even b) &lt;SEP&gt; \&lt;And&gt;a. a\&lt;^sup&gt;2 = a * a &lt;SEP&gt; \&lt;And&gt;a b. a dvd a * b</consequences_others_ascii_original>
      <consequences_others_latex>  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ even\ {\isacharparenleft}a\ {\isacharasterisk}\ b{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}even\ a\ {\isasymor}\ even\ b{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ a\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\ {\isacharasterisk}\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ a\ dvd\ a\ {\isacharasterisk}\ b\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[7]" location_in_theorem_consequence="[8]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>even &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>even b</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;even\ b\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ FREE &lt;X1&gt; ) $ ( CONST Groups.times_class.times $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) $ ( CONST Power.power_class.power2 $ FREE &lt;X2&gt; ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; b\&lt;^sup&gt;2 = 2 * c\&lt;^sup&gt;2</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;b\isactrlsup {\isadigit{2}}\ {\isacharequal}\ {\isadigit{2}}\ {\isacharasterisk}\ c\isactrlsup {\isadigit{2}}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Parity.semiring_parity_class.even $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.disj $ ( CONST Parity.semiring_parity_class.even $ BOUND 1 ) $ ( CONST Parity.semiring_parity_class.even $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST Rings.dvd_class.dvd $ BOUND 1 $ ( CONST Groups.times_class.times $ BOUND 1 $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Power.power_class.power2 $ BOUND 0 ) $ ( CONST Groups.times_class.times $ BOUND 0 $ BOUND 0 ) ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;a b. even (a * b) = (even a \&lt;or&gt; even b) &lt;SEP&gt; \&lt;And&gt;a. a\&lt;^sup&gt;2 = a * a &lt;SEP&gt; \&lt;And&gt;a b. a dvd a * b</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ even\ {\isacharparenleft}a\ {\isacharasterisk}\ b{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}even\ a\ {\isasymor}\ even\ b{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ a\isactrlsup {\isadigit{2}}\ {\isacharequal}\ a\ {\isacharasterisk}\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a\ b{\isachardot}\ a\ dvd\ a\ {\isacharasterisk}\ b\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ CONST HOL.False</consequences>
      <consequences_ascii>False</consequences_ascii>
      <consequences_ascii_original>False</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;False\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; coprime a b &lt;SEP&gt; coprime a b &lt;SEP&gt; even a &lt;SEP&gt; even a </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[8]" location_in_theorem_consequence="None" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_sqt_2_irra1">
      <target_fact>CONST HOL.Trueprop $ CONST HOL.False</target_fact>
      <target_fact_ascii>False</target_fact_ascii>
      <target_fact_ascii_original>False</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;False\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Rings.algebraic_semidom_class.coprime $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X0&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Parity.semiring_parity_class.even $ FREE &lt;X1&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; coprime a b &lt;SEP&gt; coprime a b &lt;SEP&gt; even a &lt;SEP&gt; even a &lt;SEP&gt; even b</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;coprime\ a\ b\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;even\ b\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[]" location_in_theorem_consequence="None" refinement_step_location="([],1)" refinement_step_location_consequence="None" theorem_id="thm_filterlim_sequentially_iff_filterlim_real2">
      <target_fact>CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ FREE &lt;X0&gt; $ CONST Filter.sequentially $ FREE &lt;X1&gt; ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) $ CONST Filter.at_top $ FREE &lt;X1&gt; ) )</target_fact>
      <target_fact_ascii>filterlim &lt;X0&gt; sequentially &lt;X1&gt; \&lt;Longrightarrow&gt;
LIM x &lt;X1&gt;. real (&lt;X0&gt; x) :&gt; at_top</target_fact_ascii>
      <target_fact_ascii_original>filterlim f sequentially F \&lt;Longrightarrow&gt; LIM x F. real (f x) :&gt; at_top</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;filterlim\ f\ sequentially\ F\ {\isasymLongrightarrow}\ LIM\ x\ F{\isachardot}\ real\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ at{\isacharunderscore}top\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 4 $ BOUND 3 $ BOUND 2 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ BOUND 2 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS BOUND 5 $ ( BOUND 2 $ BOUND 0 ) ) $ BOUND 3 $ BOUND 0 ) ) ) ) ) ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ CONST Real.real $ CONST Filter.at_top $ CONST Filter.sequentially )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;g F3 F2 f F1.
   \&lt;lbrakk&gt;filterlim g F3 F2; filterlim f F2 F1\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; LIM x F1. g (f x) :&gt; F3 &lt;SEP&gt; filterlim real at_top sequentially</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}g\ F{\isadigit{3}}\ F{\isadigit{2}}\ f\ F{\isadigit{1}}{\isachardot}\isanewline
\isaindent{\ \ \ }{\isasymlbrakk}filterlim\ g\ F{\isadigit{3}}\ F{\isadigit{2}}{\isacharsemicolon}\ filterlim\ f\ F{\isadigit{2}}\ F{\isadigit{1}}{\isasymrbrakk}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ g\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ F{\isadigit{3}}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;filterlim\ real\ at{\isacharunderscore}top\ sequentially\&lt;close&gt;</used_global_facts_latex>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[]" location_in_theorem_consequence="[]" refinement_step_location="([],2,[-1])" refinement_step_location_consequence="([],2,[0],0)" theorem_id="thm_filterlim_sequentially_iff_filterlim_real2">
      <target_fact>CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) $ CONST Filter.at_top $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>LIM x &lt;X1&gt;. real (&lt;X0&gt; x) :&gt; at_top</target_fact_ascii>
      <target_fact_ascii_original>LIM x F. real (f x) :&gt; at_top</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ real\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ at{\isacharunderscore}top\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Int.nat $ ( CONST Archimedean_Field.floor_ceiling_class.floor $ ( CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) ) $ CONST Filter.sequentially $ FREE &lt;X1&gt; )</consequences>
      <consequences_ascii>LIM x &lt;X1&gt;. nat \&lt;lfloor&gt;real (&lt;X0&gt; x)\&lt;rfloor&gt; :&gt; sequentially</consequences_ascii>
      <consequences_ascii_original>LIM x F. nat \&lt;lfloor&gt;real (f x)\&lt;rfloor&gt; :&gt; sequentially</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ nat\ {\isasymlfloor}real\ {\isacharparenleft}f\ x{\isacharparenright}{\isasymrfloor}\ {\isacharcolon}{\isachargreater}\ sequentially\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ CONST Filter.at_top $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Int.nat $ ( BOUND 2 $ BOUND 0 ) ) $ CONST Filter.sequentially $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ CONST Filter.at_top $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Archimedean_Field.floor_ceiling_class.floor $ ( BOUND 2 $ BOUND 0 ) ) $ CONST Filter.at_top $ BOUND 0 ) ) ) )  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) )</consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; \&lt;And&gt;f F1.
   filterlim f at_top F1 \&lt;Longrightarrow&gt;
   LIM x F1. \&lt;lfloor&gt;f x\&lt;rfloor&gt; :&gt; at_top &lt;SEP&gt; \&lt;And&gt;f F1.
   filterlim f at_top F1 \&lt;Longrightarrow&gt;
   LIM x F1. nat (f x) :&gt; sequentially  &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q</consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}f\ F{\isadigit{1}}{\isachardot}\ filterlim\ f\ at{\isacharunderscore}top\ F{\isadigit{1}}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ nat\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ sequentially\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}f\ F{\isadigit{1}}{\isachardot}\ filterlim\ f\ at{\isacharunderscore}top\ F{\isadigit{1}}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ {\isasymlfloor}f\ x{\isasymrfloor}\ {\isacharcolon}{\isachargreater}\ at{\isacharunderscore}top\&lt;close&gt;  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[]" location_in_theorem_consequence="[]" refinement_step_location="([],2,[-1])" refinement_step_location_consequence="([],2,[0])" theorem_id="thm_filterlim_sequentially_iff_filterlim_real2">
      <target_fact>CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) $ CONST Filter.at_top $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>LIM x &lt;X1&gt;. real (&lt;X0&gt; x) :&gt; at_top</target_fact_ascii>
      <target_fact_ascii_original>LIM x F. real (f x) :&gt; at_top</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ real\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ at{\isacharunderscore}top\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Int.nat $ ( CONST Archimedean_Field.floor_ceiling_class.floor $ ( CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) ) $ CONST Filter.sequentially $ FREE &lt;X1&gt; )</consequences>
      <consequences_ascii>LIM x &lt;X1&gt;. nat \&lt;lfloor&gt;real (&lt;X0&gt; x)\&lt;rfloor&gt; :&gt; sequentially</consequences_ascii>
      <consequences_ascii_original>LIM x F. nat \&lt;lfloor&gt;real (f x)\&lt;rfloor&gt; :&gt; sequentially</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ nat\ {\isasymlfloor}real\ {\isacharparenleft}f\ x{\isacharparenright}{\isasymrfloor}\ {\isacharcolon}{\isachargreater}\ sequentially\&lt;close&gt;</consequences_latex>
      <consequences_others>  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 4 $ BOUND 3 $ BOUND 2 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ BOUND 2 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS BOUND 5 $ ( BOUND 2 $ BOUND 0 ) ) $ BOUND 3 $ BOUND 0 ) ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 4 $ BOUND 3 $ BOUND 2 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ BOUND 2 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS BOUND 5 $ ( BOUND 2 $ BOUND 0 ) ) $ BOUND 3 $ BOUND 0 ) ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ CONST Int.nat $ CONST Filter.sequentially $ CONST Filter.at_top ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ CONST Archimedean_Field.floor_ceiling_class.floor $ CONST Filter.at_top $ CONST Filter.at_top )</consequences_others>
      <consequences_others_ascii_original>  &lt;SEP&gt; \&lt;And&gt;g F3 F2 f F1.
   \&lt;lbrakk&gt;filterlim g F3 F2; filterlim f F2 F1\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; LIM x F1. g (f x) :&gt; F3 &lt;SEP&gt; \&lt;And&gt;g F3 F2 f F1.
   \&lt;lbrakk&gt;filterlim g F3 F2; filterlim f F2 F1\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; LIM x F1. g (f x) :&gt; F3 &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q &lt;SEP&gt; filterlim nat sequentially at_top &lt;SEP&gt; filterlim floor at_top at_top</consequences_others_ascii_original>
      <consequences_others_latex>  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}g\ F{\isadigit{3}}\ F{\isadigit{2}}\ f\ F{\isadigit{1}}{\isachardot}\isanewline
\isaindent{\ \ \ }{\isasymlbrakk}filterlim\ g\ F{\isadigit{3}}\ F{\isadigit{2}}{\isacharsemicolon}\ filterlim\ f\ F{\isadigit{2}}\ F{\isadigit{1}}{\isasymrbrakk}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ g\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ F{\isadigit{3}}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}g\ F{\isadigit{3}}\ F{\isadigit{2}}\ f\ F{\isadigit{1}}{\isachardot}\isanewline
\isaindent{\ \ \ }{\isasymlbrakk}filterlim\ g\ F{\isadigit{3}}\ F{\isadigit{2}}{\isacharsemicolon}\ filterlim\ f\ F{\isadigit{2}}\ F{\isadigit{1}}{\isasymrbrakk}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ g\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ F{\isadigit{3}}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;filterlim\ floor\ at{\isacharunderscore}top\ at{\isacharunderscore}top\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;filterlim\ nat\ sequentially\ at{\isacharunderscore}top\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[]" location_in_theorem_consequence="None" refinement_step_location="([],2)" refinement_step_location_consequence="None" theorem_id="thm_filterlim_sequentially_iff_filterlim_real2">
      <target_fact>CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) $ CONST Filter.at_top $ FREE &lt;X1&gt; ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ FREE &lt;X0&gt; $ CONST Filter.sequentially $ FREE &lt;X1&gt; ) )</target_fact>
      <target_fact_ascii>LIM x &lt;X1&gt;. real (&lt;X0&gt; x) :&gt; at_top \&lt;Longrightarrow&gt;
filterlim &lt;X0&gt; sequentially &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>LIM x F. real (f x) :&gt; at_top \&lt;Longrightarrow&gt; filterlim f sequentially F</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ real\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ at{\isacharunderscore}top\ {\isasymLongrightarrow}\ filterlim\ f\ sequentially\ F\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 4 $ BOUND 3 $ BOUND 2 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ BOUND 2 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS BOUND 5 $ ( BOUND 2 $ BOUND 0 ) ) $ BOUND 3 $ BOUND 0 ) ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 4 $ BOUND 3 $ BOUND 2 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ BOUND 2 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS BOUND 5 $ ( BOUND 2 $ BOUND 0 ) ) $ BOUND 3 $ BOUND 0 ) ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ CONST Int.nat $ CONST Filter.sequentially $ CONST Filter.at_top ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ CONST Archimedean_Field.floor_ceiling_class.floor $ CONST Filter.at_top $ CONST Filter.at_top )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;g F3 F2 f F1.
   \&lt;lbrakk&gt;filterlim g F3 F2; filterlim f F2 F1\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; LIM x F1. g (f x) :&gt; F3 &lt;SEP&gt; \&lt;And&gt;g F3 F2 f F1.
   \&lt;lbrakk&gt;filterlim g F3 F2; filterlim f F2 F1\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; LIM x F1. g (f x) :&gt; F3 &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q &lt;SEP&gt; filterlim nat sequentially at_top &lt;SEP&gt; filterlim floor at_top at_top</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}g\ F{\isadigit{3}}\ F{\isadigit{2}}\ f\ F{\isadigit{1}}{\isachardot}\isanewline
\isaindent{\ \ \ }{\isasymlbrakk}filterlim\ g\ F{\isadigit{3}}\ F{\isadigit{2}}{\isacharsemicolon}\ filterlim\ f\ F{\isadigit{2}}\ F{\isadigit{1}}{\isasymrbrakk}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ g\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ F{\isadigit{3}}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}g\ F{\isadigit{3}}\ F{\isadigit{2}}\ f\ F{\isadigit{1}}{\isachardot}\isanewline
\isaindent{\ \ \ }{\isasymlbrakk}filterlim\ g\ F{\isadigit{3}}\ F{\isadigit{2}}{\isacharsemicolon}\ filterlim\ f\ F{\isadigit{2}}\ F{\isadigit{1}}{\isasymrbrakk}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ g\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ F{\isadigit{3}}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;filterlim\ floor\ at{\isacharunderscore}top\ at{\isacharunderscore}top\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;filterlim\ nat\ sequentially\ at{\isacharunderscore}top\&lt;close&gt;</used_global_facts_latex>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[]" location_in_theorem_consequence="[]" refinement_step_location="([],2,[0])" refinement_step_location_consequence="([],2,[1])" theorem_id="thm_filterlim_sequentially_iff_filterlim_real2">
      <target_fact>CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Int.nat $ ( CONST Archimedean_Field.floor_ceiling_class.floor $ ( CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) ) $ CONST Filter.sequentially $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>LIM x &lt;X1&gt;. nat \&lt;lfloor&gt;real (&lt;X0&gt; x)\&lt;rfloor&gt; :&gt; sequentially</target_fact_ascii>
      <target_fact_ascii_original>LIM x F. nat \&lt;lfloor&gt;real (f x)\&lt;rfloor&gt; :&gt; sequentially</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ nat\ {\isasymlfloor}real\ {\isacharparenleft}f\ x{\isacharparenright}{\isasymrfloor}\ {\isacharcolon}{\isachargreater}\ sequentially\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) $ CONST Filter.at_top $ FREE &lt;X1&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; LIM x F. real (f x) :&gt; at_top</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ real\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ at{\isacharunderscore}top\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 4 $ BOUND 3 $ BOUND 2 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ BOUND 2 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS BOUND 5 $ ( BOUND 2 $ BOUND 0 ) ) $ BOUND 3 $ BOUND 0 ) ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 4 $ BOUND 3 $ BOUND 2 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ BOUND 2 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS BOUND 5 $ ( BOUND 2 $ BOUND 0 ) ) $ BOUND 3 $ BOUND 0 ) ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ CONST Int.nat $ CONST Filter.sequentially $ CONST Filter.at_top ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ CONST Archimedean_Field.floor_ceiling_class.floor $ CONST Filter.at_top $ CONST Filter.at_top )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;g F3 F2 f F1.
   \&lt;lbrakk&gt;filterlim g F3 F2; filterlim f F2 F1\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; LIM x F1. g (f x) :&gt; F3 &lt;SEP&gt; \&lt;And&gt;g F3 F2 f F1.
   \&lt;lbrakk&gt;filterlim g F3 F2; filterlim f F2 F1\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; LIM x F1. g (f x) :&gt; F3 &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q &lt;SEP&gt; filterlim nat sequentially at_top &lt;SEP&gt; filterlim floor at_top at_top</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}g\ F{\isadigit{3}}\ F{\isadigit{2}}\ f\ F{\isadigit{1}}{\isachardot}\isanewline
\isaindent{\ \ \ }{\isasymlbrakk}filterlim\ g\ F{\isadigit{3}}\ F{\isadigit{2}}{\isacharsemicolon}\ filterlim\ f\ F{\isadigit{2}}\ F{\isadigit{1}}{\isasymrbrakk}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ g\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ F{\isadigit{3}}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}g\ F{\isadigit{3}}\ F{\isadigit{2}}\ f\ F{\isadigit{1}}{\isachardot}\isanewline
\isaindent{\ \ \ }{\isasymlbrakk}filterlim\ g\ F{\isadigit{3}}\ F{\isadigit{2}}{\isacharsemicolon}\ filterlim\ f\ F{\isadigit{2}}\ F{\isadigit{1}}{\isasymrbrakk}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ g\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ F{\isadigit{3}}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;filterlim\ floor\ at{\isacharunderscore}top\ at{\isacharunderscore}top\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;filterlim\ nat\ sequentially\ at{\isacharunderscore}top\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( CONST Filter.filterlim $ FREE &lt;X0&gt; $ CONST Filter.sequentially $ FREE &lt;X1&gt; )</consequences>
      <consequences_ascii>filterlim &lt;X0&gt; sequentially &lt;X1&gt;</consequences_ascii>
      <consequences_ascii_original>filterlim f sequentially F</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;filterlim\ f\ sequentially\ F\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[]" location_in_theorem_consequence="None" refinement_step_location="([],2,[0],0)" refinement_step_location_consequence="None" theorem_id="thm_filterlim_sequentially_iff_filterlim_real2">
      <target_fact>CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Int.nat $ ( CONST Archimedean_Field.floor_ceiling_class.floor $ ( CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) ) $ CONST Filter.sequentially $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>LIM x &lt;X1&gt;. nat \&lt;lfloor&gt;real (&lt;X0&gt; x)\&lt;rfloor&gt; :&gt; sequentially</target_fact_ascii>
      <target_fact_ascii_original>LIM x F. nat \&lt;lfloor&gt;real (f x)\&lt;rfloor&gt; :&gt; sequentially</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ nat\ {\isasymlfloor}real\ {\isacharparenleft}f\ x{\isacharparenright}{\isasymrfloor}\ {\isacharcolon}{\isachargreater}\ sequentially\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ CONST Filter.at_top $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Int.nat $ ( BOUND 2 $ BOUND 0 ) ) $ CONST Filter.sequentially $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ CONST Filter.at_top $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Archimedean_Field.floor_ceiling_class.floor $ ( BOUND 2 $ BOUND 0 ) ) $ CONST Filter.at_top $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) $ CONST Filter.at_top $ FREE &lt;X1&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;f F1.
   filterlim f at_top F1 \&lt;Longrightarrow&gt;
   LIM x F1. \&lt;lfloor&gt;f x\&lt;rfloor&gt; :&gt; at_top &lt;SEP&gt; \&lt;And&gt;f F1.
   filterlim f at_top F1 \&lt;Longrightarrow&gt;
   LIM x F1. nat (f x) :&gt; sequentially &lt;SEP&gt; LIM x F. real (f x) :&gt; at_top</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}f\ F{\isadigit{1}}{\isachardot}\ filterlim\ f\ at{\isacharunderscore}top\ F{\isadigit{1}}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ nat\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ sequentially\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}f\ F{\isadigit{1}}{\isachardot}\ filterlim\ f\ at{\isacharunderscore}top\ F{\isadigit{1}}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ {\isasymlfloor}f\ x{\isasymrfloor}\ {\isacharcolon}{\isachargreater}\ at{\isacharunderscore}top\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ real\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ at{\isacharunderscore}top\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt;</used_global_facts_latex>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="1" compound_index_consequence="None" has_consequence="True" location_in_theorem="[]" location_in_theorem_consequence="[]" refinement_step_location="([],2,[0],0)" refinement_step_location_consequence="([],2,[0],0)" theorem_id="thm_filterlim_sequentially_iff_filterlim_real2">
      <target_fact>CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ CONST Filter.at_top $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Int.nat $ ( BOUND 2 $ BOUND 0 ) ) $ CONST Filter.sequentially $ BOUND 0 ) ) ) )</target_fact>
      <target_fact_ascii>\&lt;And&gt;f F1.
   filterlim f at_top F1 \&lt;Longrightarrow&gt;
   LIM x F1. nat (f x) :&gt; sequentially</target_fact_ascii>
      <target_fact_ascii_original>\&lt;And&gt;f F1.
   filterlim f at_top F1 \&lt;Longrightarrow&gt;
   LIM x F1. nat (f x) :&gt; sequentially</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}f\ F{\isadigit{1}}{\isachardot}\ filterlim\ f\ at{\isacharunderscore}top\ F{\isadigit{1}}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ nat\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ sequentially\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 4 $ BOUND 3 $ BOUND 2 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ BOUND 2 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS BOUND 5 $ ( BOUND 2 $ BOUND 0 ) ) $ BOUND 3 $ BOUND 0 ) ) ) ) ) ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ CONST Int.nat $ CONST Filter.sequentially $ CONST Filter.at_top )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;g F3 F2 f F1.
   \&lt;lbrakk&gt;filterlim g F3 F2; filterlim f F2 F1\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; LIM x F1. g (f x) :&gt; F3 &lt;SEP&gt; filterlim nat sequentially at_top</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}g\ F{\isadigit{3}}\ F{\isadigit{2}}\ f\ F{\isadigit{1}}{\isachardot}\isanewline
\isaindent{\ \ \ }{\isasymlbrakk}filterlim\ g\ F{\isadigit{3}}\ F{\isadigit{2}}{\isacharsemicolon}\ filterlim\ f\ F{\isadigit{2}}\ F{\isadigit{1}}{\isasymrbrakk}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ g\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ F{\isadigit{3}}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;filterlim\ nat\ sequentially\ at{\isacharunderscore}top\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Int.nat $ ( CONST Archimedean_Field.floor_ceiling_class.floor $ ( CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) ) $ CONST Filter.sequentially $ FREE &lt;X1&gt; )</consequences>
      <consequences_ascii>LIM x &lt;X1&gt;. nat \&lt;lfloor&gt;real (&lt;X0&gt; x)\&lt;rfloor&gt; :&gt; sequentially</consequences_ascii>
      <consequences_ascii_original>LIM x F. nat \&lt;lfloor&gt;real (f x)\&lt;rfloor&gt; :&gt; sequentially</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ nat\ {\isasymlfloor}real\ {\isacharparenleft}f\ x{\isacharparenright}{\isasymrfloor}\ {\isacharcolon}{\isachargreater}\ sequentially\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ CONST Filter.at_top $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Archimedean_Field.floor_ceiling_class.floor $ ( BOUND 2 $ BOUND 0 ) ) $ CONST Filter.at_top $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) $ CONST Filter.at_top $ FREE &lt;X1&gt; )  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) )</consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; \&lt;And&gt;f F1.
   filterlim f at_top F1 \&lt;Longrightarrow&gt;
   LIM x F1. \&lt;lfloor&gt;f x\&lt;rfloor&gt; :&gt; at_top &lt;SEP&gt; LIM x F. real (f x) :&gt; at_top  &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q</consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}f\ F{\isadigit{1}}{\isachardot}\ filterlim\ f\ at{\isacharunderscore}top\ F{\isadigit{1}}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ {\isasymlfloor}f\ x{\isasymrfloor}\ {\isacharcolon}{\isachargreater}\ at{\isacharunderscore}top\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ real\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ at{\isacharunderscore}top\&lt;close&gt;  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="2" compound_index_consequence="None" has_consequence="True" location_in_theorem="[]" location_in_theorem_consequence="[]" refinement_step_location="([],2,[0],0)" refinement_step_location_consequence="([],2,[0],0)" theorem_id="thm_filterlim_sequentially_iff_filterlim_real2">
      <target_fact>CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ CONST Filter.at_top $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Archimedean_Field.floor_ceiling_class.floor $ ( BOUND 2 $ BOUND 0 ) ) $ CONST Filter.at_top $ BOUND 0 ) ) ) )</target_fact>
      <target_fact_ascii>\&lt;And&gt;f F1.
   filterlim f at_top F1 \&lt;Longrightarrow&gt;
   LIM x F1. \&lt;lfloor&gt;f x\&lt;rfloor&gt; :&gt; at_top</target_fact_ascii>
      <target_fact_ascii_original>\&lt;And&gt;f F1.
   filterlim f at_top F1 \&lt;Longrightarrow&gt;
   LIM x F1. \&lt;lfloor&gt;f x\&lt;rfloor&gt; :&gt; at_top</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}f\ F{\isadigit{1}}{\isachardot}\ filterlim\ f\ at{\isacharunderscore}top\ F{\isadigit{1}}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ {\isasymlfloor}f\ x{\isasymrfloor}\ {\isacharcolon}{\isachargreater}\ at{\isacharunderscore}top\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 4 $ BOUND 3 $ BOUND 2 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ BOUND 2 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS BOUND 5 $ ( BOUND 2 $ BOUND 0 ) ) $ BOUND 3 $ BOUND 0 ) ) ) ) ) ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ CONST Archimedean_Field.floor_ceiling_class.floor $ CONST Filter.at_top $ CONST Filter.at_top )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;g F3 F2 f F1.
   \&lt;lbrakk&gt;filterlim g F3 F2; filterlim f F2 F1\&lt;rbrakk&gt;
   \&lt;Longrightarrow&gt; LIM x F1. g (f x) :&gt; F3 &lt;SEP&gt; filterlim floor at_top at_top</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}g\ F{\isadigit{3}}\ F{\isadigit{2}}\ f\ F{\isadigit{1}}{\isachardot}\isanewline
\isaindent{\ \ \ }{\isasymlbrakk}filterlim\ g\ F{\isadigit{3}}\ F{\isadigit{2}}{\isacharsemicolon}\ filterlim\ f\ F{\isadigit{2}}\ F{\isadigit{1}}{\isasymrbrakk}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ g\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ F{\isadigit{3}}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;filterlim\ floor\ at{\isacharunderscore}top\ at{\isacharunderscore}top\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Int.nat $ ( CONST Archimedean_Field.floor_ceiling_class.floor $ ( CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) ) $ CONST Filter.sequentially $ FREE &lt;X1&gt; )</consequences>
      <consequences_ascii>LIM x &lt;X1&gt;. nat \&lt;lfloor&gt;real (&lt;X0&gt; x)\&lt;rfloor&gt; :&gt; sequentially</consequences_ascii>
      <consequences_ascii_original>LIM x F. nat \&lt;lfloor&gt;real (f x)\&lt;rfloor&gt; :&gt; sequentially</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ nat\ {\isasymlfloor}real\ {\isacharparenleft}f\ x{\isacharparenright}{\isasymrfloor}\ {\isacharcolon}{\isachargreater}\ sequentially\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ BOUND 1 $ CONST Filter.at_top $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Int.nat $ ( BOUND 2 $ BOUND 0 ) ) $ CONST Filter.sequentially $ BOUND 0 ) ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) $ CONST Filter.at_top $ FREE &lt;X1&gt; )  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) )</consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; \&lt;And&gt;f F1.
   filterlim f at_top F1 \&lt;Longrightarrow&gt;
   LIM x F1. nat (f x) :&gt; sequentially &lt;SEP&gt; LIM x F. real (f x) :&gt; at_top  &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q</consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}f\ F{\isadigit{1}}{\isachardot}\ filterlim\ f\ at{\isacharunderscore}top\ F{\isadigit{1}}\ {\isasymLongrightarrow}\ LIM\ x\ F{\isadigit{1}}{\isachardot}\ nat\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ sequentially\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ real\ {\isacharparenleft}f\ x{\isacharparenright}\ {\isacharcolon}{\isachargreater}\ at{\isacharunderscore}top\&lt;close&gt;  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[]" location_in_theorem_consequence="None" refinement_step_location="([],2,[1])" refinement_step_location_consequence="None" theorem_id="thm_filterlim_sequentially_iff_filterlim_real2">
      <target_fact>CONST HOL.Trueprop $ ( CONST Filter.filterlim $ FREE &lt;X0&gt; $ CONST Filter.sequentially $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>filterlim &lt;X0&gt; sequentially &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>filterlim f sequentially F</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;filterlim\ f\ sequentially\ F\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST Filter.filterlim $ ( ABS CONST Int.nat $ ( CONST Archimedean_Field.floor_ceiling_class.floor $ ( CONST Real.real $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) ) $ CONST Filter.sequentially $ FREE &lt;X1&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; LIM x F. nat \&lt;lfloor&gt;real (f x)\&lt;rfloor&gt; :&gt; sequentially</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;LIM\ x\ F{\isachardot}\ nat\ {\isasymlfloor}real\ {\isacharparenleft}f\ x{\isacharparenright}{\isasymrfloor}\ {\isacharcolon}{\isachargreater}\ sequentially\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[3]" location_in_theorem_consequence="[4]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo16">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) )</target_fact>
      <target_fact_ascii>&lt;X2&gt; = 2</target_fact_ascii>
      <target_fact_ascii_original>b = 2</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;b\ {\isacharequal}\ {\isadigit{2}}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 0 $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) ) $ ( CONST HOL.Trueprop $ FREE thesis__ ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;b. b = 2 \&lt;Longrightarrow&gt; thesis</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}b{\isachardot}\ b\ {\isacharequal}\ {\isadigit{2}}\ {\isasymLongrightarrow}\ thesis\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ CONST HOL.False</consequences>
      <consequences_ascii>False</consequences_ascii>
      <consequences_ascii_original>False</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;False\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[3,-1]" location_in_theorem_consequence="[3]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo16">
      <target_fact>CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 0 $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) ) $ ( CONST HOL.Trueprop $ FREE thesis__ ) )</target_fact>
      <target_fact_ascii>\&lt;And&gt;b. b = 2 \&lt;Longrightarrow&gt; thesis</target_fact_ascii>
      <target_fact_ascii_original>\&lt;And&gt;b. b = 2 \&lt;Longrightarrow&gt; thesis</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}b{\isachardot}\ b\ {\isacharequal}\ {\isadigit{2}}\ {\isasymLongrightarrow}\ thesis\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) )</consequences>
      <consequences_ascii>&lt;X2&gt; = 2</consequences_ascii>
      <consequences_ascii_original>b = 2</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;b\ {\isacharequal}\ {\isadigit{2}}\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[4]" location_in_theorem_consequence="None" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo16">
      <target_fact>CONST HOL.Trueprop $ CONST HOL.False</target_fact>
      <target_fact_ascii>False</target_fact_ascii>
      <target_fact_ascii_original>False</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;False\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; b = 2</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;b\ {\isacharequal}\ {\isadigit{2}}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="1" compound_index_consequence="None" has_consequence="False" location_in_theorem="[]" location_in_theorem_consequence="None" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_fact_in_Reals7">
      <target_fact>CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ CONST Groups.one_class.one $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( CONST Groups.plus_class.plus $ CONST Groups.one_class.one ) $ ( CONST Groups.plus_class.plus $ ( CONST Num.numeral_class.numeral $ ( CONST Num.num.Bit0 $ CONST Num.num.One ) ) ) ) )</target_fact>
      <target_fact_ascii>(1::?'c1) = (2::?'c1) \&lt;Longrightarrow&gt; (+) (1::?'c1) = (+) (2::?'c1)</target_fact_ascii>
      <target_fact_ascii_original>(1::?'c1) = (2::?'c1) \&lt;Longrightarrow&gt; (+) (1::?'c1) = (+) (2::?'c1)</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isacharparenleft}{\isadigit{1}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}c{\isadigit{1}}{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}{\isadigit{2}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}c{\isadigit{1}}{\isacharparenright}\ {\isasymLongrightarrow}\ {\isacharparenleft}{\isacharplus}{\isacharparenright}\ {\isacharparenleft}{\isadigit{1}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}c{\isadigit{1}}{\isacharparenright}\ {\isacharequal}\ {\isacharparenleft}{\isacharplus}{\isacharparenright}\ {\isacharparenleft}{\isadigit{2}}{\isacharcolon}{\isacharcolon}{\isacharquery}{\isacharprime}c{\isadigit{1}}{\isacharparenright}\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 3 $ BOUND 2 ) ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 1 $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.eq $ ( BOUND 3 $ BOUND 1 ) $ ( BOUND 2 $ BOUND 0 ) ) ) ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.eq $ BOUND 0 $ BOUND 0 ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;f g x y. \&lt;lbrakk&gt;f = g; x = y\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; f x = g y &lt;SEP&gt; \&lt;And&gt;t. t = t</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}f\ g\ x\ y{\isachardot}\ {\isasymlbrakk}f\ {\isacharequal}\ g{\isacharsemicolon}\ x\ {\isacharequal}\ y{\isasymrbrakk}\ {\isasymLongrightarrow}\ f\ x\ {\isacharequal}\ g\ y\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}t{\isachardot}\ t\ {\isacharequal}\ t\&lt;close&gt;</used_global_facts_latex>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="0" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>&lt;X0&gt; = &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>A = B</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ B\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; = &lt;X2&gt;</consequences_ascii>
      <consequences_ascii_original>A = C</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X1&gt; $ FREE &lt;X2&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; B = C </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;B\ {\isacharequal}\ C\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>&lt;X0&gt; = &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>A = B</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ B\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X3&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; = &lt;X3&gt;</consequences_ascii>
      <consequences_ascii_original>A = D</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ D\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X1&gt; $ FREE &lt;X2&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; B = C &lt;SEP&gt; C = D &lt;SEP&gt; A = C &lt;SEP&gt; C = D </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;B\ {\isacharequal}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="0" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X1&gt; $ FREE &lt;X2&gt; )</target_fact>
      <target_fact_ascii>&lt;X1&gt; = &lt;X2&gt;</target_fact_ascii>
      <target_fact_ascii_original>B = C</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;B\ {\isacharequal}\ C\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; = &lt;X2&gt;</consequences_ascii>
      <consequences_ascii_original>A = C</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; A = B </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ B\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X1&gt; $ FREE &lt;X2&gt; )</target_fact>
      <target_fact_ascii>&lt;X1&gt; = &lt;X2&gt;</target_fact_ascii>
      <target_fact_ascii_original>B = C</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;B\ {\isacharequal}\ C\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X3&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; = &lt;X3&gt;</consequences_ascii>
      <consequences_ascii_original>A = D</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ D\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; A = B &lt;SEP&gt; C = D &lt;SEP&gt; A = C &lt;SEP&gt; C = D </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ B\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; )</target_fact>
      <target_fact_ascii>&lt;X2&gt; = &lt;X3&gt;</target_fact_ascii>
      <target_fact_ascii_original>C = D</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; = &lt;X2&gt;</consequences_ascii>
      <consequences_ascii_original>A = C</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; A = C </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; )</target_fact>
      <target_fact_ascii>&lt;X2&gt; = &lt;X3&gt;</target_fact_ascii>
      <target_fact_ascii_original>C = D</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; )</consequences>
      <consequences_ascii>&lt;X2&gt; = &lt;X3&gt;</consequences_ascii>
      <consequences_ascii_original>C = D</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; A = C </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; )</target_fact>
      <target_fact_ascii>&lt;X2&gt; = &lt;X3&gt;</target_fact_ascii>
      <target_fact_ascii_original>C = D</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; = &lt;X2&gt;</consequences_ascii>
      <consequences_ascii_original>A = C</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; A = C </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; )</target_fact>
      <target_fact_ascii>&lt;X2&gt; = &lt;X3&gt;</target_fact_ascii>
      <target_fact_ascii_original>C = D</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; )</consequences>
      <consequences_ascii>&lt;X2&gt; = &lt;X3&gt;</consequences_ascii>
      <consequences_ascii_original>C = D</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; A = C </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; )</target_fact>
      <target_fact_ascii>&lt;X2&gt; = &lt;X3&gt;</target_fact_ascii>
      <target_fact_ascii_original>C = D</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; C = D &lt;SEP&gt; C = D &lt;SEP&gt; A = C</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X3&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; = &lt;X3&gt;</consequences_ascii>
      <consequences_ascii_original>A = D</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ D\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X1&gt; $ FREE &lt;X2&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; A = B &lt;SEP&gt; B = C &lt;SEP&gt; A = C </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ B\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;B\ {\isacharequal}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; )</target_fact>
      <target_fact_ascii>&lt;X2&gt; = &lt;X3&gt;</target_fact_ascii>
      <target_fact_ascii_original>C = D</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; C = D &lt;SEP&gt; C = D &lt;SEP&gt; A = C</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X3&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; = &lt;X3&gt;</consequences_ascii>
      <consequences_ascii_original>A = D</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ D\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X1&gt; $ FREE &lt;X2&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; A = B &lt;SEP&gt; B = C &lt;SEP&gt; A = C </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ B\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;B\ {\isacharequal}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; )</target_fact>
      <target_fact_ascii>&lt;X0&gt; = &lt;X2&gt;</target_fact_ascii>
      <target_fact_ascii_original>A = C</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; C = D &lt;SEP&gt; C = D &lt;SEP&gt; A = C</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X3&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; = &lt;X3&gt;</consequences_ascii>
      <consequences_ascii_original>A = D</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ D\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X1&gt; $ FREE &lt;X2&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; A = B &lt;SEP&gt; B = C &lt;SEP&gt; C = D &lt;SEP&gt; C = D </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ B\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;B\ {\isacharequal}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="0" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; )</target_fact>
      <target_fact_ascii>&lt;X0&gt; = &lt;X2&gt;</target_fact_ascii>
      <target_fact_ascii_original>A = C</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X1&gt; $ FREE &lt;X2&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; A = B &lt;SEP&gt; B = C</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ B\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;B\ {\isacharequal}\ C\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; = &lt;X2&gt;</consequences_ascii>
      <consequences_ascii_original>A = C</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; C = D &lt;SEP&gt; C = D </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="0" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; )</target_fact>
      <target_fact_ascii>&lt;X0&gt; = &lt;X2&gt;</target_fact_ascii>
      <target_fact_ascii_original>A = C</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X1&gt; $ FREE &lt;X2&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; A = B &lt;SEP&gt; B = C</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ B\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;B\ {\isacharequal}\ C\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; )</consequences>
      <consequences_ascii>&lt;X2&gt; = &lt;X3&gt;</consequences_ascii>
      <consequences_ascii_original>C = D</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; C = D &lt;SEP&gt; C = D </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[2]" location_in_theorem_consequence="None" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_foo8">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X3&gt; )</target_fact>
      <target_fact_ascii>&lt;X0&gt; = &lt;X3&gt;</target_fact_ascii>
      <target_fact_ascii_original>A = D</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ D\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X1&gt; $ FREE &lt;X2&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X0&gt; $ FREE &lt;X2&gt; ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.eq $ FREE &lt;X2&gt; $ FREE &lt;X3&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; A = B &lt;SEP&gt; B = C &lt;SEP&gt; C = D &lt;SEP&gt; A = C &lt;SEP&gt; C = D</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ B\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;B\ {\isacharequal}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;A\ {\isacharequal}\ C\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;C\ {\isacharequal}\ D\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[-1]" location_in_theorem_consequence="[2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) )</target_fact>
      <target_fact_ascii>\&lt;not&gt; (\&lt;forall&gt;x. &lt;X0&gt; x)</target_fact_ascii>
      <target_fact_ascii_original>\&lt;not&gt; (\&lt;forall&gt;x. P x)</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ P\ x{\isacharparenright}\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) )</consequences>
      <consequences_ascii>\&lt;exists&gt;x. \&lt;not&gt; &lt;X0&gt; x</consequences_ascii>
      <consequences_ascii_original>\&lt;exists&gt;x. \&lt;not&gt; P x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; \&lt;forall&gt;x. P x </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ P\ x\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[-1]" location_in_theorem_consequence="[2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) )</target_fact>
      <target_fact_ascii>\&lt;not&gt; (\&lt;forall&gt;x. &lt;X0&gt; x)</target_fact_ascii>
      <target_fact_ascii_original>\&lt;not&gt; (\&lt;forall&gt;x. P x)</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ P\ x{\isacharparenright}\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) )</consequences>
      <consequences_ascii>\&lt;exists&gt;x. \&lt;not&gt; &lt;X0&gt; x</consequences_ascii>
      <consequences_ascii_original>\&lt;exists&gt;x. \&lt;not&gt; P x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; \&lt;forall&gt;x. P x </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ P\ x\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="1" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[1,1,2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</target_fact>
      <target_fact_ascii>\&lt;nexists&gt;x. \&lt;not&gt; &lt;X0&gt; x</target_fact_ascii>
      <target_fact_ascii_original>\&lt;nexists&gt;x. \&lt;not&gt; P x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) )</consequences>
      <consequences_ascii>\&lt;forall&gt;x. &lt;X0&gt; x</consequences_ascii>
      <consequences_ascii_original>\&lt;forall&gt;x. P x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ P\ x\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[1,1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</target_fact>
      <target_fact_ascii>\&lt;nexists&gt;x. \&lt;not&gt; &lt;X0&gt; x</target_fact_ascii>
      <target_fact_ascii_original>\&lt;nexists&gt;x. \&lt;not&gt; P x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; &lt;X1&gt;</consequences_ascii>
      <consequences_ascii_original>P x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;P\ x\&lt;close&gt;</consequences_latex>
      <consequences_others>  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.Not $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ CONST HOL.False ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ CONST HOL.True</consequences_others>
      <consequences_others_ascii_original>  &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q &lt;SEP&gt; \&lt;And&gt;P. (\&lt;not&gt; P \&lt;Longrightarrow&gt; P) \&lt;Longrightarrow&gt; P &lt;SEP&gt; \&lt;And&gt;P. False \&lt;Longrightarrow&gt; P &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; True</consequences_others_ascii_original>
      <consequences_others_latex>  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ {\isacharparenleft}{\isasymnot}\ P\ {\isasymLongrightarrow}\ P{\isacharparenright}\ {\isasymLongrightarrow}\ P\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ False\ {\isasymLongrightarrow}\ P\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;True\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</target_fact>
      <target_fact_ascii>\&lt;nexists&gt;x. \&lt;not&gt; &lt;X0&gt; x</target_fact_ascii>
      <target_fact_ascii_original>\&lt;nexists&gt;x. \&lt;not&gt; P x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) )</consequences>
      <consequences_ascii>\&lt;forall&gt;x. &lt;X0&gt; x</consequences_ascii>
      <consequences_ascii_original>\&lt;forall&gt;x. P x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ P\ x\&lt;close&gt;</consequences_latex>
      <consequences_others>  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.Not $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ CONST HOL.False ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ CONST HOL.True</consequences_others>
      <consequences_others_ascii_original>  &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q &lt;SEP&gt; \&lt;And&gt;P. (\&lt;not&gt; P \&lt;Longrightarrow&gt; P) \&lt;Longrightarrow&gt; P &lt;SEP&gt; \&lt;And&gt;P. False \&lt;Longrightarrow&gt; P &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; True</consequences_others_ascii_original>
      <consequences_others_latex>  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ {\isacharparenleft}{\isasymnot}\ P\ {\isasymLongrightarrow}\ P{\isacharparenright}\ {\isasymLongrightarrow}\ P\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ False\ {\isasymLongrightarrow}\ P\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;True\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) )</target_fact>
      <target_fact_ascii>\&lt;forall&gt;x. &lt;X0&gt; x</target_fact_ascii>
      <target_fact_ascii_original>\&lt;forall&gt;x. P x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ P\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;nexists&gt;x. \&lt;not&gt; P x</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.Not $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ CONST HOL.False ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ CONST HOL.True</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q &lt;SEP&gt; \&lt;And&gt;P. (\&lt;not&gt; P \&lt;Longrightarrow&gt; P) \&lt;Longrightarrow&gt; P &lt;SEP&gt; \&lt;And&gt;P. False \&lt;Longrightarrow&gt; P &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; True</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ {\isacharparenleft}{\isasymnot}\ P\ {\isasymLongrightarrow}\ P{\isacharparenright}\ {\isasymLongrightarrow}\ P\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ False\ {\isasymLongrightarrow}\ P\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;True\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) )</consequences>
      <consequences_ascii>\&lt;exists&gt;x. \&lt;not&gt; &lt;X0&gt; x</consequences_ascii>
      <consequences_ascii_original>\&lt;exists&gt;x. \&lt;not&gt; P x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; \&lt;not&gt; (\&lt;forall&gt;x. P x) &lt;SEP&gt; \&lt;not&gt; (\&lt;forall&gt;x. P x) </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ P\ x{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ P\ x{\isacharparenright}\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="1" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1,1,2]" location_in_theorem_consequence="[1,1,2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) )</target_fact>
      <target_fact_ascii>\&lt;forall&gt;x. &lt;X0&gt; x</target_fact_ascii>
      <target_fact_ascii_original>\&lt;forall&gt;x. P x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ P\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;nexists&gt;x. \&lt;not&gt; P x</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; &lt;X1&gt;</consequences_ascii>
      <consequences_ascii_original>P x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;P\ x\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ CONST HOL.False ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ CONST HOL.True</consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; \&lt;exists&gt;x. \&lt;not&gt; P x &lt;SEP&gt; \&lt;not&gt; P x  &lt;SEP&gt; \&lt;And&gt;P. False \&lt;Longrightarrow&gt; P &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; True</consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ P\ x\&lt;close&gt;  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ False\ {\isasymLongrightarrow}\ P\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;True\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[1,1]" location_in_theorem_consequence="None" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>&lt;X0&gt; &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>P x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;P\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;nexists&gt;x. \&lt;not&gt; P x</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.Not $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ CONST HOL.False ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ CONST HOL.True</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q &lt;SEP&gt; \&lt;And&gt;P. (\&lt;not&gt; P \&lt;Longrightarrow&gt; P) \&lt;Longrightarrow&gt; P &lt;SEP&gt; \&lt;And&gt;P. False \&lt;Longrightarrow&gt; P &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; True</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ {\isacharparenleft}{\isasymnot}\ P\ {\isasymLongrightarrow}\ P{\isacharparenright}\ {\isasymLongrightarrow}\ P\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ False\ {\isasymLongrightarrow}\ P\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;True\&lt;close&gt;</used_global_facts_latex>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[1,1,2]" location_in_theorem_consequence="None" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>&lt;X0&gt; &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>P x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;P\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;exists&gt;x. \&lt;not&gt; P x &lt;SEP&gt; \&lt;forall&gt;x. P x &lt;SEP&gt; \&lt;not&gt; P x</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ P\ x\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ P\ x\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ CONST HOL.False ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ CONST HOL.True</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;P. False \&lt;Longrightarrow&gt; P &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; True</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ False\ {\isasymLongrightarrow}\ P\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;True\&lt;close&gt;</used_global_facts_latex>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1,1,0]" location_in_theorem_consequence="[1,1,1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )</target_fact>
      <target_fact_ascii>\&lt;not&gt; &lt;X0&gt; &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>\&lt;not&gt; P x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ P\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) )</consequences>
      <consequences_ascii>\&lt;exists&gt;x. \&lt;not&gt; &lt;X0&gt; x</consequences_ascii>
      <consequences_ascii_original>\&lt;exists&gt;x. \&lt;not&gt; P x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="2" has_consequence="True" location_in_theorem="[1,1,0]" location_in_theorem_consequence="[1,1,2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )</target_fact>
      <target_fact_ascii>\&lt;not&gt; &lt;X0&gt; &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>\&lt;not&gt; P x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ P\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )</consequences>
      <consequences_ascii>\&lt;not&gt; &lt;X0&gt; &lt;X1&gt;</consequences_ascii>
      <consequences_ascii_original>\&lt;not&gt; P x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ P\ x\&lt;close&gt;</consequences_latex>
      <consequences_others>  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) )</consequences_others>
      <consequences_others_ascii_original>  &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q</consequences_others_ascii_original>
      <consequences_others_latex>  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="2" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1,1,2]" location_in_theorem_consequence="[1,1,2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )</target_fact>
      <target_fact_ascii>\&lt;not&gt; &lt;X0&gt; &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>\&lt;not&gt; P x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ P\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;not&gt; P x</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ P\ x\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 1 ) $ ( CONST Pure.imp $ ( CONST HOL.Trueprop $ BOUND 0 ) $ ( CONST HOL.Trueprop $ ( CONST HOL.conj $ BOUND 1 $ BOUND 0 ) ) ) ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;P Q. \&lt;lbrakk&gt;P; Q\&lt;rbrakk&gt; \&lt;Longrightarrow&gt; P \&lt;and&gt; Q</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P\ Q{\isachardot}\ {\isasymlbrakk}P{\isacharsemicolon}\ Q{\isasymrbrakk}\ {\isasymLongrightarrow}\ P\ {\isasymand}\ Q\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; &lt;X1&gt;</consequences_ascii>
      <consequences_ascii_original>P x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;P\ x\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) )  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ CONST HOL.False ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ CONST HOL.True</consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; \&lt;exists&gt;x. \&lt;not&gt; P x &lt;SEP&gt; \&lt;forall&gt;x. P x  &lt;SEP&gt; \&lt;And&gt;P. False \&lt;Longrightarrow&gt; P &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; True</consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ P\ x\&lt;close&gt;  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ False\ {\isasymLongrightarrow}\ P\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;True\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1,1,1]" location_in_theorem_consequence="[1,1,2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) )</target_fact>
      <target_fact_ascii>\&lt;exists&gt;x. \&lt;not&gt; &lt;X0&gt; x</target_fact_ascii>
      <target_fact_ascii_original>\&lt;exists&gt;x. \&lt;not&gt; P x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;not&gt; P x</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ P\ x\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</consequences>
      <consequences_ascii>&lt;X0&gt; &lt;X1&gt;</consequences_ascii>
      <consequences_ascii_original>P x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;P\ x\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ CONST HOL.False ) $ ( CONST HOL.Trueprop $ BOUND 0 ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.not_equal $ CONST HOL.False $ CONST HOL.True ) &lt;SEP&gt; CONST HOL.Trueprop $ CONST HOL.True</consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; \&lt;forall&gt;x. P x &lt;SEP&gt; \&lt;not&gt; P x  &lt;SEP&gt; \&lt;And&gt;P. False \&lt;Longrightarrow&gt; P &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; False \&lt;noteq&gt; True &lt;SEP&gt; True</consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ P\ x\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ P\ x\&lt;close&gt;  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ False\ {\isasymLongrightarrow}\ P\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;False\ {\isasymnoteq}\ True\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;True\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[2]" location_in_theorem_consequence="None" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_de_Morgan9">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) )</target_fact>
      <target_fact_ascii>\&lt;exists&gt;x. \&lt;not&gt; &lt;X0&gt; x</target_fact_ascii>
      <target_fact_ascii_original>\&lt;exists&gt;x. \&lt;not&gt; P x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;not&gt; (\&lt;forall&gt;x. P x) &lt;SEP&gt; \&lt;not&gt; (\&lt;forall&gt;x. P x) &lt;SEP&gt; \&lt;forall&gt;x. P x</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ P\ x{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ P\ x{\isacharparenright}\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ P\ x\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[0]" location_in_theorem_consequence="[1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_Drinker's_Principle10">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) )</target_fact>
      <target_fact_ascii>\&lt;forall&gt;x. &lt;X0&gt; x</target_fact_ascii>
      <target_fact_ascii_original>\&lt;forall&gt;x. drunk x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ drunk\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.implies $ ( FREE &lt;X0&gt; $ BOUND 0 ) $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</consequences>
      <consequences_ascii>\&lt;And&gt;a. &lt;X0&gt; a \&lt;longrightarrow&gt; (\&lt;forall&gt;x. &lt;X0&gt; x)</consequences_ascii>
      <consequences_ascii_original>\&lt;And&gt;a. drunk a \&lt;longrightarrow&gt; (\&lt;forall&gt;x. drunk x)</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ drunk\ a\ {\isasymlongrightarrow}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ drunk\ x{\isacharparenright}\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[7,1]" location_in_theorem_consequence="None" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_Drinker's_Principle10">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) )</target_fact>
      <target_fact_ascii>\&lt;forall&gt;x. &lt;X0&gt; x</target_fact_ascii>
      <target_fact_ascii_original>\&lt;forall&gt;x. drunk x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ drunk\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;not&gt; drunk a &lt;SEP&gt; \&lt;not&gt; drunk a &lt;SEP&gt; drunk a</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ drunk\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ drunk\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;drunk\ a\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[1]" location_in_theorem_consequence="[2]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_Drinker's_Principle10">
      <target_fact>CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.implies $ ( FREE &lt;X0&gt; $ BOUND 0 ) $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</target_fact>
      <target_fact_ascii>\&lt;And&gt;a. &lt;X0&gt; a \&lt;longrightarrow&gt; (\&lt;forall&gt;x. &lt;X0&gt; x)</target_fact_ascii>
      <target_fact_ascii_original>\&lt;And&gt;a. drunk a \&lt;longrightarrow&gt; (\&lt;forall&gt;x. drunk x)</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ drunk\ a\ {\isasymlongrightarrow}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ drunk\ x{\isacharparenright}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;forall&gt;x. drunk x</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ drunk\ x\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.implies $ ( FREE &lt;X0&gt; $ BOUND 0 ) $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</consequences>
      <consequences_ascii>\&lt;exists&gt;x. &lt;X0&gt; x \&lt;longrightarrow&gt; (\&lt;forall&gt;x. &lt;X0&gt; x)</consequences_ascii>
      <consequences_ascii_original>\&lt;exists&gt;x. drunk x \&lt;longrightarrow&gt; (\&lt;forall&gt;x. drunk x)</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ drunk\ x\ {\isasymlongrightarrow}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ drunk\ x{\isacharparenright}\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[2]" location_in_theorem_consequence="None" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_Drinker's_Principle10">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.implies $ ( FREE &lt;X0&gt; $ BOUND 0 ) $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</target_fact>
      <target_fact_ascii>\&lt;exists&gt;x. &lt;X0&gt; x \&lt;longrightarrow&gt; (\&lt;forall&gt;x. &lt;X0&gt; x)</target_fact_ascii>
      <target_fact_ascii_original>\&lt;exists&gt;x. drunk x \&lt;longrightarrow&gt; (\&lt;forall&gt;x. drunk x)</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ drunk\ x\ {\isasymlongrightarrow}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ drunk\ x{\isacharparenright}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST HOL.Trueprop $ ( CONST HOL.implies $ ( FREE &lt;X0&gt; $ BOUND 0 ) $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;a. drunk a \&lt;longrightarrow&gt; (\&lt;forall&gt;x. drunk x)</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}a{\isachardot}\ drunk\ a\ {\isasymlongrightarrow}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ drunk\ x{\isacharparenright}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="False" location_in_theorem="[8]" location_in_theorem_consequence="None" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_Drinker's_Principle10">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.implies $ ( FREE &lt;X0&gt; $ BOUND 0 ) $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</target_fact>
      <target_fact_ascii>\&lt;exists&gt;x. &lt;X0&gt; x \&lt;longrightarrow&gt; (\&lt;forall&gt;x. &lt;X0&gt; x)</target_fact_ascii>
      <target_fact_ascii_original>\&lt;exists&gt;x. drunk x \&lt;longrightarrow&gt; (\&lt;forall&gt;x. drunk x)</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ drunk\ x\ {\isasymlongrightarrow}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ drunk\ x{\isacharparenright}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.implies $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; drunk a \&lt;longrightarrow&gt; (\&lt;forall&gt;x. drunk x)</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;drunk\ a\ {\isasymlongrightarrow}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ drunk\ x{\isacharparenright}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences/>
      <consequences_ascii/>
      <consequences_ascii_original/>
      <consequences_latex/>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[4]" location_in_theorem_consequence="[5]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_Drinker's_Principle10">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) )</target_fact>
      <target_fact_ascii>\&lt;not&gt; (\&lt;forall&gt;x. &lt;X0&gt; x)</target_fact_ascii>
      <target_fact_ascii_original>\&lt;not&gt; (\&lt;forall&gt;x. drunk x)</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ drunk\ x{\isacharparenright}\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) )</consequences>
      <consequences_ascii>\&lt;exists&gt;x. \&lt;not&gt; &lt;X0&gt; x</consequences_ascii>
      <consequences_ascii_original>\&lt;exists&gt;x. \&lt;not&gt; drunk x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ drunk\ x\&lt;close&gt;</consequences_latex>
      <consequences_others>  &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.All $ ( ABS BOUND 1 $ BOUND 0 ) ) ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( BOUND 1 $ BOUND 0 ) ) ) ) )</consequences_others>
      <consequences_others_ascii_original>  &lt;SEP&gt; \&lt;And&gt;P. \&lt;not&gt; (\&lt;forall&gt;x. P x) \&lt;Longrightarrow&gt; \&lt;exists&gt;x. \&lt;not&gt; P x</consequences_others_ascii_original>
      <consequences_others_latex>  &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ {\isasymnot}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ P\ x{\isacharparenright}\ {\isasymLongrightarrow}\ {\isasymexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[5]" location_in_theorem_consequence="[6]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_Drinker's_Principle10">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) )</target_fact>
      <target_fact_ascii>\&lt;exists&gt;x. \&lt;not&gt; &lt;X0&gt; x</target_fact_ascii>
      <target_fact_ascii_original>\&lt;exists&gt;x. \&lt;not&gt; drunk x</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ drunk\ x\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;not&gt; (\&lt;forall&gt;x. drunk x)</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ drunk\ x{\isacharparenright}\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts> &lt;SEP&gt; CONST Pure.all $ ( ABS CONST Pure.imp $ ( CONST HOL.Trueprop $ ( CONST HOL.Not $ ( CONST HOL.All $ ( ABS BOUND 1 $ BOUND 0 ) ) ) ) $ ( CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( BOUND 1 $ BOUND 0 ) ) ) ) )</used_global_facts>
      <used_global_facts_ascii_original> &lt;SEP&gt; \&lt;And&gt;P. \&lt;not&gt; (\&lt;forall&gt;x. P x) \&lt;Longrightarrow&gt; \&lt;exists&gt;x. \&lt;not&gt; P x</used_global_facts_ascii_original>
      <used_global_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymAnd}P{\isachardot}\ {\isasymnot}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ P\ x{\isacharparenright}\ {\isasymLongrightarrow}\ {\isasymexists}x{\isachardot}\ {\isasymnot}\ P\ x\&lt;close&gt;</used_global_facts_latex>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )</consequences>
      <consequences_ascii>\&lt;not&gt; &lt;X0&gt; &lt;X1&gt;</consequences_ascii>
      <consequences_ascii_original>\&lt;not&gt; drunk a</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ drunk\ a\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[6]" location_in_theorem_consequence="[7,1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_Drinker's_Principle10">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )</target_fact>
      <target_fact_ascii>\&lt;not&gt; &lt;X0&gt; &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>\&lt;not&gt; drunk a</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ drunk\ a\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;exists&gt;x. \&lt;not&gt; drunk x</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ drunk\ x\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) )</consequences>
      <consequences_ascii>\&lt;forall&gt;x. &lt;X0&gt; x</consequences_ascii>
      <consequences_ascii_original>\&lt;forall&gt;x. drunk x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ drunk\ x\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; drunk a </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;drunk\ a\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[6]" location_in_theorem_consequence="[7,1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_Drinker's_Principle10">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )</target_fact>
      <target_fact_ascii>\&lt;not&gt; &lt;X0&gt; &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>\&lt;not&gt; drunk a</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ drunk\ a\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;exists&gt;x. \&lt;not&gt; drunk x</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ drunk\ x\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) )</consequences>
      <consequences_ascii>\&lt;forall&gt;x. &lt;X0&gt; x</consequences_ascii>
      <consequences_ascii_original>\&lt;forall&gt;x. drunk x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ drunk\ x\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; drunk a </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;drunk\ a\&lt;close&gt; </consequences_others_latex>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[6]" location_in_theorem_consequence="[7]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_Drinker's_Principle10">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )</target_fact>
      <target_fact_ascii>\&lt;not&gt; &lt;X0&gt; &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>\&lt;not&gt; drunk a</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ drunk\ a\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.Not $ ( FREE &lt;X0&gt; $ BOUND 0 ) ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;exists&gt;x. \&lt;not&gt; drunk x</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ {\isasymnot}\ drunk\ x\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.implies $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) )</consequences>
      <consequences_ascii>&lt;X0&gt; &lt;X1&gt; \&lt;longrightarrow&gt; (\&lt;forall&gt;x. &lt;X0&gt; x)</consequences_ascii>
      <consequences_ascii_original>drunk a \&lt;longrightarrow&gt; (\&lt;forall&gt;x. drunk x)</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;drunk\ a\ {\isasymlongrightarrow}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ drunk\ x{\isacharparenright}\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[7]" location_in_theorem_consequence="[8]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_Drinker's_Principle10">
      <target_fact>CONST HOL.Trueprop $ ( CONST HOL.implies $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) )</target_fact>
      <target_fact_ascii>&lt;X0&gt; &lt;X1&gt; \&lt;longrightarrow&gt; (\&lt;forall&gt;x. &lt;X0&gt; x)</target_fact_ascii>
      <target_fact_ascii_original>drunk a \&lt;longrightarrow&gt; (\&lt;forall&gt;x. drunk x)</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;drunk\ a\ {\isasymlongrightarrow}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ drunk\ x{\isacharparenright}\&lt;close&gt;</target_fact_latex>
      <used_local_facts> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) )</used_local_facts>
      <used_local_facts_ascii_original> &lt;SEP&gt; \&lt;not&gt; drunk a</used_local_facts_ascii_original>
      <used_local_facts_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ drunk\ a\&lt;close&gt;</used_local_facts_latex>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.Ex $ ( ABS CONST HOL.implies $ ( FREE &lt;X0&gt; $ BOUND 0 ) $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) ) ) )</consequences>
      <consequences_ascii>\&lt;exists&gt;x. &lt;X0&gt; x \&lt;longrightarrow&gt; (\&lt;forall&gt;x. &lt;X0&gt; x)</consequences_ascii>
      <consequences_ascii_original>\&lt;exists&gt;x. drunk x \&lt;longrightarrow&gt; (\&lt;forall&gt;x. drunk x)</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymexists}x{\isachardot}\ drunk\ x\ {\isasymlongrightarrow}\ {\isacharparenleft}{\isasymforall}x{\isachardot}\ drunk\ x{\isacharparenright}\&lt;close&gt;</consequences_latex>
      <consequences_others/>
      <consequences_others_ascii_original/>
      <consequences_others_latex/>
   </entry>
   <entry compound_index="None" compound_index_consequence="None" has_consequence="True" location_in_theorem="[7,0]" location_in_theorem_consequence="[7,1]" refinement_step_location="None" refinement_step_location_consequence="None" theorem_id="thm_Drinker's_Principle10">
      <target_fact>CONST HOL.Trueprop $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; )</target_fact>
      <target_fact_ascii>&lt;X0&gt; &lt;X1&gt;</target_fact_ascii>
      <target_fact_ascii_original>drunk a</target_fact_ascii_original>
      <target_fact_latex>\&lt;^latex&gt;\&lt;open&gt;drunk\ a\&lt;close&gt;</target_fact_latex>
      <used_local_facts/>
      <used_local_facts_ascii_original/>
      <used_local_facts_latex/>
      <used_global_facts/>
      <used_global_facts_ascii_original/>
      <used_global_facts_latex/>
      <consequences>CONST HOL.Trueprop $ ( CONST HOL.All $ ( ABS FREE &lt;X0&gt; $ BOUND 0 ) )</consequences>
      <consequences_ascii>\&lt;forall&gt;x. &lt;X0&gt; x</consequences_ascii>
      <consequences_ascii_original>\&lt;forall&gt;x. drunk x</consequences_ascii_original>
      <consequences_latex>\&lt;^latex&gt;\&lt;open&gt;{\isasymforall}x{\isachardot}\ drunk\ x\&lt;close&gt;</consequences_latex>
      <consequences_others> &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) ) &lt;SEP&gt; CONST HOL.Trueprop $ ( CONST HOL.Not $ ( FREE &lt;X0&gt; $ FREE &lt;X1&gt; ) ) </consequences_others>
      <consequences_others_ascii_original> &lt;SEP&gt; \&lt;not&gt; drunk a &lt;SEP&gt; \&lt;not&gt; drunk a </consequences_others_ascii_original>
      <consequences_others_latex> &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ drunk\ a\&lt;close&gt; &lt;SEP&gt; \&lt;^latex&gt;\&lt;open&gt;{\isasymnot}\ drunk\ a\&lt;close&gt; </consequences_others_latex>
   </entry>
</theory>
